{"version":3,"file":"pgs-parser-worker.js","mappings":"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","sources":["webpack://@project/extension/../node_modules/pgs-parser/dist/buffer.js","webpack://@project/extension/../node_modules/pgs-parser/dist/index.js","webpack://@project/extension/../node_modules/pgs-parser/dist/parser.js","webpack://@project/extension/../node_modules/pgs-parser/dist/segment.js","webpack://@project/extension/webpack/bootstrap","webpack://@project/extension/../common/subtitle-reader/pgs-parser-worker.ts"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BufferReader = exports.CompositeBufferReader = exports.CompositeBuffer = exports.Uint8ArrayBuffer = void 0;\nclass Uint8ArrayBuffer {\n    constructor(buffer) {\n        this.buffer = buffer;\n    }\n    get length() {\n        return this.buffer.length;\n    }\n    at(index) {\n        return this.buffer[index];\n    }\n    subarray(start, end) {\n        return new Uint8ArrayBuffer(this.buffer.subarray(start, end));\n    }\n}\nexports.Uint8ArrayBuffer = Uint8ArrayBuffer;\nclass CompositeBuffer {\n    constructor(buffers) {\n        this.buffers = [];\n        this.buffers = buffers;\n    }\n    get length() {\n        let length = 0;\n        for (const b of this.buffers) {\n            length += b.length;\n        }\n        return length;\n    }\n    at(index) {\n        let previousBuffersLength = 0;\n        for (const buffer of this.buffers) {\n            const bufferIndex = index - previousBuffersLength;\n            if (bufferIndex < buffer.length) {\n                return buffer.at(bufferIndex);\n            }\n            previousBuffersLength += buffer.length;\n        }\n        throw new Error('Out of bounds');\n    }\n    subarray(start, end) {\n        const chunks = [];\n        let previousBuffersLength = 0;\n        for (const buffer of this.buffers) {\n            const startBufferIndex = Math.max(0, start - previousBuffersLength);\n            const endBufferIndex = Math.min(buffer.length, end - previousBuffersLength);\n            if (endBufferIndex > 0 && startBufferIndex < endBufferIndex) {\n                chunks.push(buffer.subarray(startBufferIndex, endBufferIndex));\n            }\n            previousBuffersLength += buffer.length;\n        }\n        return new CompositeBuffer(chunks);\n    }\n}\nexports.CompositeBuffer = CompositeBuffer;\nclass CompositeBufferReader {\n    constructor() {\n        this.buffers = [];\n    }\n    add(buffer) {\n        this.buffers.push(buffer);\n    }\n    get length() {\n        let length = 0;\n        for (const buffer of this.buffers) {\n            length += buffer.length;\n        }\n        return length;\n    }\n    read(bytes) {\n        if (bytes === 0) {\n            return new CompositeBuffer([]);\n        }\n        const chunks = [];\n        let accumulated = 0;\n        while (true) {\n            if (this.buffers.length === 0) {\n                throw new Error('Trying to read more bytes than available');\n            }\n            const buffer = this.buffers.shift();\n            const required = bytes - accumulated;\n            if (buffer.length === required) {\n                chunks.push(buffer);\n                break;\n            }\n            else if (buffer.length > required) {\n                chunks.push(buffer.subarray(0, required));\n                this.buffers.unshift(buffer.subarray(required, buffer.length));\n                break;\n            }\n            accumulated += buffer.length;\n            chunks.push(buffer);\n        }\n        return new CompositeBuffer(chunks.map(c => new Uint8ArrayBuffer(c)));\n    }\n}\nexports.CompositeBufferReader = CompositeBufferReader;\nclass BufferReader {\n    constructor(bytes) {\n        this._index = 0;\n        this.buffer = bytes;\n    }\n    get index() {\n        return this._index;\n    }\n    get hasNext() {\n        return this._index < this.buffer.length;\n    }\n    readHex(bytes, limit) {\n        if (limit !== undefined && this._index + bytes > limit) {\n            return 0;\n        }\n        let number = 0;\n        let digit = 0;\n        const from = this._index;\n        const to = this._index + bytes - 1;\n        for (let i = to; i >= from; --i) {\n            number += this.buffer.at(i) << (8 * digit);\n            ++digit;\n        }\n        this._index += bytes;\n        return number;\n    }\n    readBuffer(bytes) {\n        const buffer = this.buffer.subarray(this.index, this.index + bytes);\n        this._index += bytes;\n        return buffer;\n    }\n}\nexports.BufferReader = BufferReader;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LastInSequenceFlag = exports.CompositionState = exports.SegmentType = exports.DisplaySet = exports.parseDisplaySets = void 0;\nvar parser_1 = require(\"./parser\");\nObject.defineProperty(exports, \"parseDisplaySets\", { enumerable: true, get: function () { return parser_1.parseDisplaySets; } });\nObject.defineProperty(exports, \"DisplaySet\", { enumerable: true, get: function () { return parser_1.DisplaySet; } });\nvar segment_1 = require(\"./segment\");\nObject.defineProperty(exports, \"SegmentType\", { enumerable: true, get: function () { return segment_1.SegmentType; } });\nObject.defineProperty(exports, \"CompositionState\", { enumerable: true, get: function () { return segment_1.CompositionState; } });\nObject.defineProperty(exports, \"LastInSequenceFlag\", { enumerable: true, get: function () { return segment_1.LastInSequenceFlag; } });\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DisplaySet = exports.parseDisplaySets = void 0;\nconst buffer_1 = require(\"./buffer\");\nconst segment_1 = require(\"./segment\");\nconst pgMagicNumber = 20551; // 0x5047\nfunction parseDisplaySets() {\n    const parser = new DisplaySetParser();\n    const accumulatedBuffer = new buffer_1.CompositeBufferReader();\n    let requestedBytes = 13;\n    return new TransformStream({\n        transform(chunk, controller) {\n            accumulatedBuffer.add(chunk);\n            while (accumulatedBuffer.length >= requestedBytes) {\n                requestedBytes = parser.consume(accumulatedBuffer.read(requestedBytes));\n                if (parser.ready) {\n                    controller.enqueue(parser.next());\n                }\n            }\n        },\n        flush(controller) {\n            if (parser.ready) {\n                controller.enqueue(parser.next());\n            }\n        },\n    });\n}\nexports.parseDisplaySets = parseDisplaySets;\nfunction rleDecode(encodedBuffer, callback) {\n    let encodedIndex = 0;\n    let decodedLineIndex = 0;\n    let currentLine = 0;\n    const encodedLength = encodedBuffer.length;\n    while (encodedIndex < encodedLength) {\n        const firstByte = encodedBuffer.at(encodedIndex);\n        let runLength;\n        let color;\n        let increment;\n        // Deal with each possible code\n        if (firstByte > 0) {\n            // CCCCCCCC\t- One pixel in color C\n            color = firstByte;\n            runLength = 1;\n            increment = 1;\n        }\n        else {\n            const secondByte = encodedBuffer.at(encodedIndex + 1);\n            if (secondByte === 0) {\n                // 00000000 00000000 - End of line\n                color = 0;\n                runLength = 0;\n                increment = 2;\n                decodedLineIndex = 0;\n                ++currentLine;\n            }\n            else if (secondByte < 64) {\n                // 00000000 00LLLLLL - L pixels in color 0 (L between 1 and 63)\n                color = 0;\n                runLength = secondByte;\n                increment = 2;\n            }\n            else if (secondByte < 128) {\n                // 00000000 01LLLLLL LLLLLLLL - L pixels in color 0 (L between 64 and 16383)\n                const thirdByte = encodedBuffer.at(encodedIndex + 2);\n                color = 0;\n                runLength = ((secondByte - 64) << 8) + thirdByte;\n                increment = 3;\n            }\n            else if (secondByte < 192) {\n                // 00000000 10LLLLLL CCCCCCCC - L pixels in color C (L between 3 and 63)\n                const thirdByte = encodedBuffer.at(encodedIndex + 2);\n                color = thirdByte;\n                runLength = secondByte - 128;\n                increment = 3;\n            }\n            else {\n                // 00000000 11LLLLLL LLLLLLLL CCCCCCCC - L pixels in color C (L between 64 and 16383)\n                const thirdByte = encodedBuffer.at(encodedIndex + 2);\n                const fourthByte = encodedBuffer.at(encodedIndex + 3);\n                color = fourthByte;\n                runLength = ((secondByte - 192) << 8) + thirdByte;\n                increment = 4;\n            }\n        }\n        if (runLength > 0) {\n            for (let x = decodedLineIndex; x < decodedLineIndex + runLength; ++x) {\n                callback(x, currentLine, color);\n            }\n            decodedLineIndex += runLength;\n        }\n        encodedIndex += increment;\n    }\n}\nclass DisplaySet {\n    constructor(presentationCompositionSegment, windowDefinitionSegments, paletteDefinitionSegments, objectDefinitionSegments, endDefinitionSegment, previousDisplaySet) {\n        this.presentationCompositionSegment = presentationCompositionSegment;\n        this.windowDefinitionSegments = windowDefinitionSegments;\n        this.paletteDefinitionSegments = paletteDefinitionSegments;\n        this.objectDefinitionSegments = objectDefinitionSegments;\n        this.endDefinitionSegment = endDefinitionSegment;\n        this.previousDisplaySet = previousDisplaySet;\n    }\n    get firstOds() {\n        return this.objectDefinitionSegments.find((ods) => ods.lastInSequenceFlag === segment_1.LastInSequenceFlag.firstInSequence ||\n            ods.lastInSequenceFlag === segment_1.LastInSequenceFlag.firstAndLastInSequence);\n    }\n    paletteDefinitionSegment(paletteId) {\n        const pds = this.paletteDefinitionSegments.find((s) => s.paletteId === paletteId);\n        if (pds === undefined) {\n            if (this.presentationCompositionSegment.compositionState !== segment_1.CompositionState.normal) {\n                throw new Error(`PCS references invalid PDS and composition state is not 'normal'`);\n            }\n            if (this.previousDisplaySet === undefined) {\n                throw new Error(`PCS references invalid PDS and no previous display set to fallback to`);\n            }\n            return this.previousDisplaySet.paletteDefinitionSegment(paletteId);\n        }\n        return pds;\n    }\n    imageData(buffer) {\n        const pds = this.paletteDefinitionSegment(this.presentationCompositionSegment.paletteId);\n        if (pds === undefined) {\n            throw new Error(`PCS references invalid PDS`);\n        }\n        const firstOds = this.firstOds;\n        if (firstOds === undefined || firstOds.width === undefined || firstOds.height === undefined) {\n            throw new Error(`Missing first ODS with defined width and height`);\n        }\n        const imageDataArray = buffer !== null && buffer !== void 0 ? buffer : new Uint8ClampedArray(firstOds.width * firstOds.height * 4);\n        const rgbaPalette = pds.paletteEntries.map((palette) => this.ycrcbToRgba(palette));\n        const width = firstOds.width;\n        rleDecode(new buffer_1.CompositeBuffer(this.objectDefinitionSegments.map((ods) => ods.objectData)), (x, y, paletteIndex) => {\n            const pixelIndex = y * width + x;\n            const imageDataOffset = pixelIndex * 4;\n            if (paletteIndex >= rgbaPalette.length) {\n                imageDataArray[imageDataOffset] = 0;\n                imageDataArray[imageDataOffset + 1] = 0;\n                imageDataArray[imageDataOffset + 2] = 0;\n                imageDataArray[imageDataOffset + 3] = 0;\n            }\n            else {\n                const color = rgbaPalette[paletteIndex];\n                imageDataArray[imageDataOffset] = color.r;\n                imageDataArray[imageDataOffset + 1] = color.g;\n                imageDataArray[imageDataOffset + 2] = color.b;\n                imageDataArray[imageDataOffset + 3] = color.a;\n            }\n        });\n        return new ImageData(imageDataArray.subarray(0, 4 * firstOds.width * firstOds.height), firstOds.width, firstOds.height);\n    }\n    // https://stackoverflow.com/questions/21264648/javascript-convert-yuv-to-rgb\n    ycrcbToRgba(palette) {\n        const y = palette.luminance;\n        const cb = palette.colorDifferenceBlue;\n        const cr = palette.colorDifferenceRed;\n        const r = this.clamp(Math.floor(y + 1.4075 * (cr - 128)), 0, 255);\n        const g = this.clamp(Math.floor(y - 0.3455 * (cb - 128) - 0.7169 * (cr - 128)), 0, 255);\n        const b = this.clamp(Math.floor(y + 1.779 * (cb - 128)), 0, 255);\n        return { r, g, b, a: palette.transparency };\n    }\n    clamp(number, min, max) {\n        return Math.max(min, Math.min(max, number));\n    }\n}\nexports.DisplaySet = DisplaySet;\nclass DisplaySetParser {\n    constructor() {\n        this.windowDefinitionSegments = [];\n        this.paletteDefinitionSegments = [];\n        this.objectDefinitionSegments = [];\n        this.ready = false;\n    }\n    next() {\n        this.ready = false;\n        return this.lastDisplaySet;\n    }\n    consume(buffer) {\n        const reader = new buffer_1.BufferReader(buffer);\n        if (this.header) {\n            switch (this.header.segmentType) {\n                case segment_1.SegmentType.pcs:\n                    if (this.presentationCompositionSegment !== undefined) {\n                        throw new Error(`Unexpected PDS`);\n                    }\n                    this.presentationCompositionSegment = parsePcsSegment(reader, this.header);\n                    break;\n                case segment_1.SegmentType.wds:\n                    if (this.presentationCompositionSegment === undefined) {\n                        throw new Error(`Unexpected WDS`);\n                    }\n                    this.windowDefinitionSegments.push(parseWdsSegment(reader, this.header));\n                    break;\n                case segment_1.SegmentType.pds:\n                    if (this.presentationCompositionSegment === undefined) {\n                        throw new Error(`Unexpected PDS`);\n                    }\n                    this.paletteDefinitionSegments.push(parsePdsSegment(reader, this.header));\n                    break;\n                case segment_1.SegmentType.ods:\n                    if (this.presentationCompositionSegment === undefined) {\n                        throw new Error(`Unexpected ODS`);\n                    }\n                    const ods = parseOdsSegment(reader, this.header);\n                    this.objectDefinitionSegments.push(ods);\n                    break;\n                case segment_1.SegmentType.end:\n                    if (this.presentationCompositionSegment === undefined) {\n                        throw new Error(`Unexpected end segment`);\n                    }\n                    const endDefinitionSegment = { header: this.header };\n                    this.lastDisplaySet = new DisplaySet(this.presentationCompositionSegment, this.windowDefinitionSegments, this.paletteDefinitionSegments, this.objectDefinitionSegments, endDefinitionSegment, this.lastDisplaySet);\n                    this.ready = true;\n                    this.presentationCompositionSegment = undefined;\n                    this.windowDefinitionSegments = [];\n                    this.paletteDefinitionSegments = [];\n                    this.objectDefinitionSegments = [];\n                    break;\n                default:\n                    throw new Error(`Unknown segment type: ${this.header.segmentType}`);\n            }\n            this.header = undefined;\n            return 13;\n        }\n        else {\n            const magicNumber = reader.readHex(2);\n            if (magicNumber !== pgMagicNumber) {\n                throw new Error(`Invalid magic number: ${magicNumber}`);\n            }\n            const presentationTimestamp = reader.readHex(4);\n            const decodingTimestamp = reader.readHex(4);\n            const segmentType = (0, segment_1.segmentTypeFromByte)(reader.readHex(1));\n            const segmentSize = reader.readHex(2);\n            this.header = { presentationTimestamp, decodingTimestamp, segmentType, segmentSize };\n            return segmentSize;\n        }\n    }\n}\nfunction parsePcsSegment(reader, header) {\n    const limit = reader.index + header.segmentSize;\n    const width = reader.readHex(2, limit);\n    const height = reader.readHex(2, limit);\n    reader.readHex(1); // ignore frame rate\n    const compositionNumber = reader.readHex(2, limit);\n    const compositionState = (0, segment_1.compositionStateFromByte)(reader.readHex(1, limit));\n    const paletteUpdateFlag = (0, segment_1.paletteUpdateFlagFromByte)(reader.readHex(1, limit));\n    const paletteId = reader.readHex(1, limit);\n    const compositionObjectCount = reader.readHex(1, limit);\n    const objectId = reader.readHex(2, limit);\n    const windowId = reader.readHex(1, limit);\n    const objectCroppedFlag = (0, segment_1.objectCroppedFlagFromByte)(reader.readHex(1, limit));\n    const objectHorizontalPosition = reader.readHex(2, limit);\n    const objectVerticalPosition = reader.readHex(2, limit);\n    const objectCroppingHorizontalPosition = reader.readHex(2, limit);\n    const objectCroppingVerticalPosition = reader.readHex(2, limit);\n    const objectCroppingWidth = reader.readHex(2, limit);\n    const objectCroppingHeightPosition = reader.readHex(2, limit);\n    return {\n        header,\n        width,\n        height,\n        compositionNumber,\n        compositionState,\n        paletteUpdateFlag,\n        paletteId,\n        compositionObjectCount,\n        objectId,\n        windowId,\n        objectCroppedFlag,\n        objectHorizontalPosition,\n        objectVerticalPosition,\n        objectCroppingHorizontalPosition,\n        objectCroppingVerticalPosition,\n        objectCroppingWidth,\n        objectCroppingHeightPosition,\n    };\n}\nfunction parseWdsSegment(reader, header) {\n    const limit = reader.index + header.segmentSize;\n    const windowCount = reader.readHex(1, limit);\n    const windowDefinitions = [];\n    for (let i = 0; i < windowCount; ++i) {\n        const windowId = reader.readHex(1, limit);\n        const windowHorizontalPosition = reader.readHex(2, limit);\n        const windowVerticalPosition = reader.readHex(2, limit);\n        const windowWidth = reader.readHex(2, limit);\n        const windowHeight = reader.readHex(2, limit);\n        windowDefinitions.push({\n            windowId,\n            windowHorizontalPosition,\n            windowVerticalPosition,\n            windowWidth,\n            windowHeight,\n        });\n    }\n    return {\n        header,\n        windowCount,\n        windowDefinitions,\n    };\n}\nfunction parsePdsSegment(reader, header) {\n    const limit = reader.index + header.segmentSize;\n    const paletteId = reader.readHex(1, limit);\n    const paletteVersionNumber = reader.readHex(1, limit);\n    const paletteEntries = [];\n    while (reader.index < limit) {\n        const paletteEntryId = reader.readHex(1, limit);\n        const luminance = reader.readHex(1, limit);\n        const colorDifferenceRed = reader.readHex(1, limit);\n        const colorDifferenceBlue = reader.readHex(1, limit);\n        const transparency = reader.readHex(1, limit);\n        paletteEntries.push({ paletteEntryId, luminance, colorDifferenceRed, colorDifferenceBlue, transparency });\n    }\n    return {\n        header,\n        paletteId,\n        paletteVersionNumber,\n        paletteEntries,\n    };\n}\nfunction parseOdsSegment(reader, header) {\n    const objectId = reader.readHex(2);\n    const objectVersionNumber = reader.readHex(1);\n    const lastInSequenceFlag = (0, segment_1.lastInSequenceFlagFromByte)(reader.readHex(1));\n    const objectDataLength = reader.readHex(3);\n    let width;\n    let height;\n    let objectData;\n    if (lastInSequenceFlag === segment_1.LastInSequenceFlag.firstInSequence ||\n        lastInSequenceFlag === segment_1.LastInSequenceFlag.firstAndLastInSequence) {\n        width = reader.readHex(2);\n        height = reader.readHex(2);\n        objectData = reader.readBuffer(objectDataLength - 4);\n    }\n    else {\n        objectData = reader.readBuffer(objectDataLength);\n    }\n    return {\n        header,\n        objectId,\n        objectVersionNumber,\n        lastInSequenceFlag,\n        objectDataLength,\n        width,\n        height,\n        objectData: objectData,\n    };\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.lastInSequenceFlagFromByte = exports.LastInSequenceFlag = exports.objectCroppedFlagFromByte = exports.paletteUpdateFlagFromByte = exports.compositionStateFromByte = exports.CompositionState = exports.segmentTypeFromByte = exports.SegmentType = void 0;\nvar SegmentType;\n(function (SegmentType) {\n    SegmentType[SegmentType[\"pds\"] = 20] = \"pds\";\n    SegmentType[SegmentType[\"ods\"] = 21] = \"ods\";\n    SegmentType[SegmentType[\"pcs\"] = 22] = \"pcs\";\n    SegmentType[SegmentType[\"wds\"] = 23] = \"wds\";\n    SegmentType[SegmentType[\"end\"] = 128] = \"end\";\n})(SegmentType = exports.SegmentType || (exports.SegmentType = {}));\nconst segmentTypeValues = Object.values(SegmentType);\nfunction segmentTypeFromByte(byte) {\n    for (const type of segmentTypeValues) {\n        if (byte === type) {\n            return type;\n        }\n    }\n    throw new Error(`Invalid segment type byte: ${byte}`);\n}\nexports.segmentTypeFromByte = segmentTypeFromByte;\nvar CompositionState;\n(function (CompositionState) {\n    CompositionState[CompositionState[\"normal\"] = 0] = \"normal\";\n    CompositionState[CompositionState[\"acquisitionState\"] = 64] = \"acquisitionState\";\n    CompositionState[CompositionState[\"epochStart\"] = 128] = \"epochStart\";\n})(CompositionState = exports.CompositionState || (exports.CompositionState = {}));\nconst compositionStateValues = Object.values(CompositionState);\nfunction compositionStateFromByte(byte) {\n    for (const state of compositionStateValues) {\n        if (byte === state) {\n            return state;\n        }\n    }\n    throw new Error(`Invalid composition state byte: ${byte}`);\n}\nexports.compositionStateFromByte = compositionStateFromByte;\nfunction paletteUpdateFlagFromByte(byte) {\n    switch (byte) {\n        case 0:\n            return false;\n        case 128:\n            return true;\n        default:\n            throw new Error(`Invalid palette update flag byte: ${byte}`);\n    }\n}\nexports.paletteUpdateFlagFromByte = paletteUpdateFlagFromByte;\nfunction objectCroppedFlagFromByte(byte) {\n    switch (byte) {\n        case 0:\n            return false;\n        case 64:\n            return true;\n        default:\n            throw new Error(`Invalid object cropped flag byte: ${byte}`);\n    }\n}\nexports.objectCroppedFlagFromByte = objectCroppedFlagFromByte;\nvar LastInSequenceFlag;\n(function (LastInSequenceFlag) {\n    LastInSequenceFlag[LastInSequenceFlag[\"lastInSequence\"] = 64] = \"lastInSequence\";\n    LastInSequenceFlag[LastInSequenceFlag[\"firstInSequence\"] = 128] = \"firstInSequence\";\n    LastInSequenceFlag[LastInSequenceFlag[\"firstAndLastInSequence\"] = 192] = \"firstAndLastInSequence\";\n})(LastInSequenceFlag = exports.LastInSequenceFlag || (exports.LastInSequenceFlag = {}));\nconst lastInSequenceFlagValues = Object.values(LastInSequenceFlag);\nfunction lastInSequenceFlagFromByte(byte) {\n    for (const flag of lastInSequenceFlagValues) {\n        if (byte === flag) {\n            return flag;\n        }\n    }\n    throw new Error(`Invalid last in sequence flag byte: ${byte}`);\n}\nexports.lastInSequenceFlagFromByte = lastInSequenceFlagFromByte;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { parseDisplaySets } from 'pgs-parser';\n// OffscreenCanvas not in lib.dom.d.ts\n// @ts-ignore\nfunction parse(fileStream, canvas) {\n    let currentImageDisplaySet;\n    let imageDataArray;\n    fileStream.pipeThrough(parseDisplaySets()).pipeTo(new WritableStream({\n        close() {\n            postMessage({\n                command: 'finished',\n            });\n        },\n        abort(error) {\n            postMessage({\n                command: 'error',\n                error,\n            });\n        },\n        async write(displaySet, controller) {\n            if (displaySet.objectDefinitionSegments.length > 0) {\n                if (currentImageDisplaySet === undefined) {\n                    currentImageDisplaySet = displaySet;\n                }\n            }\n            else if (currentImageDisplaySet !== undefined) {\n                const screenWidth = currentImageDisplaySet.presentationCompositionSegment.width;\n                const screenHeight = currentImageDisplaySet.presentationCompositionSegment.height;\n                imageDataArray =\n                    imageDataArray === undefined || imageDataArray.length < screenHeight * screenWidth * 4\n                        ? new Uint8ClampedArray(screenWidth * screenHeight * 4)\n                        : imageDataArray;\n                const imageData = currentImageDisplaySet.imageData(imageDataArray);\n                canvas.width = imageData.width;\n                canvas.height = imageData.height;\n                const context = canvas.getContext('2d');\n                context.putImageData(imageData, 0, 0);\n                postMessage({\n                    command: 'subtitle',\n                    imageBlob: await canvas.convertToBlob({ type: 'image/png' }),\n                    subtitle: {\n                        start: currentImageDisplaySet.objectDefinitionSegments[0].header.presentationTimestamp / 90 ??\n                            0,\n                        end: displaySet.endDefinitionSegment.header.presentationTimestamp / 90,\n                        text: '',\n                        textImage: {\n                            image: {\n                                width: imageData.width,\n                                height: imageData.height,\n                            },\n                            screen: {\n                                width: currentImageDisplaySet.presentationCompositionSegment.width,\n                                height: currentImageDisplaySet.presentationCompositionSegment.height,\n                            },\n                        },\n                    },\n                });\n                currentImageDisplaySet = undefined;\n            }\n        },\n    }));\n}\nonmessage = async (e) => {\n    const { fileStream, canvas } = e.data;\n    parse(fileStream, canvas);\n};\n"],"names":["Object","defineProperty","exports","value","BufferReader","CompositeBufferReader","CompositeBuffer","Uint8ArrayBuffer","constructor","buffer","this","length","at","index","subarray","start","end","buffers","b","previousBuffersLength","bufferIndex","Error","chunks","startBufferIndex","Math","max","endBufferIndex","min","push","add","read","bytes","accumulated","shift","required","unshift","map","c","_index","hasNext","readHex","limit","undefined","number","digit","from","i","readBuffer","parser_1","enumerable","get","parseDisplaySets","DisplaySet","buffer_1","segment_1","parser","DisplaySetParser","accumulatedBuffer","requestedBytes","TransformStream","transform","chunk","controller","consume","ready","enqueue","next","flush","presentationCompositionSegment","windowDefinitionSegments","paletteDefinitionSegments","objectDefinitionSegments","endDefinitionSegment","previousDisplaySet","firstOds","find","ods","lastInSequenceFlag","LastInSequenceFlag","firstInSequence","firstAndLastInSequence","paletteDefinitionSegment","paletteId","pds","s","compositionState","CompositionState","normal","imageData","width","height","imageDataArray","Uint8ClampedArray","rgbaPalette","paletteEntries","palette","ycrcbToRgba","encodedBuffer","callback","encodedIndex","decodedLineIndex","currentLine","encodedLength","firstByte","runLength","color","increment","secondByte","thirdByte","x","rleDecode","objectData","y","paletteIndex","imageDataOffset","r","g","a","ImageData","luminance","cb","colorDifferenceBlue","cr","colorDifferenceRed","clamp","floor","transparency","lastDisplaySet","reader","header","segmentType","SegmentType","pcs","segmentSize","compositionNumber","compositionStateFromByte","paletteUpdateFlag","paletteUpdateFlagFromByte","compositionObjectCount","objectId","windowId","objectCroppedFlag","objectCroppedFlagFromByte","objectHorizontalPosition","objectVerticalPosition","objectCroppingHorizontalPosition","objectCroppingVerticalPosition","objectCroppingWidth","objectCroppingHeightPosition","parsePcsSegment","wds","windowCount","windowDefinitions","windowHorizontalPosition","windowVerticalPosition","windowWidth","windowHeight","parseWdsSegment","paletteVersionNumber","paletteEntryId","parsePdsSegment","objectVersionNumber","lastInSequenceFlagFromByte","objectDataLength","parseOdsSegment","magicNumber","presentationTimestamp","decodingTimestamp","segmentTypeFromByte","segmentTypeValues","values","byte","type","compositionStateValues","state","lastInSequenceFlagValues","flag","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","module","__webpack_modules__","onmessage","async","e","fileStream","canvas","data","currentImageDisplaySet","pipeThrough","pipeTo","WritableStream","close","postMessage","command","abort","error","write","displaySet","screenWidth","screenHeight","getContext","putImageData","imageBlob","convertToBlob","subtitle","text","textImage","image","screen","parse"],"sourceRoot":""}