{"version":3,"file":"/pages/hulu-page.js","mappings":"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","sources":["webpack://@project/extension/./src/pages/util.ts","webpack://@project/extension/webpack/bootstrap","webpack://@project/extension/webpack/runtime/define property getters","webpack://@project/extension/webpack/runtime/hasOwnProperty shorthand","webpack://@project/extension/./src/pages/hulu-page.ts"],"sourcesContent":["export function extractExtension(url, fallback) {\n    const dotIndex = url.lastIndexOf('.');\n    let extension = fallback;\n    if (dotIndex !== -1) {\n        extension = url.substring(dotIndex + 1);\n        // Account for case when URL has a query parameter\n        const questionMarkIndex = extension.indexOf('?');\n        if (questionMarkIndex !== -1) {\n            extension = extension.substring(0, questionMarkIndex);\n        }\n    }\n    return extension;\n}\nexport function poll(test, timeout = 10000) {\n    return new Promise(async (resolve, reject) => {\n        if (test()) {\n            resolve(true);\n        }\n        const t0 = Date.now();\n        let passed = false;\n        while (!passed && Date.now() < t0 + timeout) {\n            await new Promise((loopResolve) => {\n                setTimeout(() => {\n                    passed = test();\n                    loopResolve();\n                }, 1000);\n            });\n        }\n        resolve(passed);\n    });\n}\nexport const trackFromDef = (def) => {\n    return { id: trackId(def), ...def };\n};\nexport const trackId = (def) => {\n    return `${def.language}:${def.label}:${def.url}`;\n};\nexport function inferTracks({ onJson, onRequest, waitForBasename }) {\n    setTimeout(() => {\n        const subtitlesByPath = {};\n        let basename = '';\n        let trackDataRequestHandled = false;\n        if (onJson !== undefined) {\n            const originalParse = JSON.parse;\n            JSON.parse = function () {\n                // @ts-ignore\n                const value = originalParse.apply(this, arguments);\n                let tracksFound = false;\n                let basenameFound = false;\n                onJson?.(value, (track) => {\n                    const path = window.location.pathname;\n                    if (typeof subtitlesByPath[path] === 'undefined') {\n                        subtitlesByPath[path] = [];\n                    }\n                    const newId = trackId(track);\n                    if (subtitlesByPath[path].find((s) => s.id === newId) === undefined) {\n                        subtitlesByPath[path].push({ id: newId, ...track });\n                        tracksFound = true;\n                    }\n                }, (theBasename) => {\n                    basename = theBasename;\n                    basenameFound = true;\n                });\n                if (trackDataRequestHandled && (tracksFound || basenameFound)) {\n                    // Only notify additional tracks after the initial request for track info\n                    document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n                        detail: {\n                            error: '',\n                            basename: basename,\n                            subtitles: subtitlesByPath[window.location.pathname],\n                        },\n                    }));\n                }\n                return value;\n            };\n        }\n        function garbageCollect() {\n            for (const path of Object.keys(subtitlesByPath)) {\n                if (path !== window.location.pathname) {\n                    delete subtitlesByPath[path];\n                }\n            }\n        }\n        document.addEventListener('asbplayer-get-synced-data', async () => {\n            onRequest?.((track) => {\n                const path = window.location.pathname;\n                if (typeof subtitlesByPath[path] === 'undefined') {\n                    subtitlesByPath[path] = [];\n                }\n                const newId = trackId(track);\n                if (subtitlesByPath[path].find((s) => s.id === newId) === undefined) {\n                    subtitlesByPath[path].push({ id: newId, ...track });\n                }\n            }, (theBasename) => {\n                basename = theBasename;\n                if (!trackDataRequestHandled) {\n                    // Notify basename even if still waiting for subtitle track info\n                    document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n                        detail: {\n                            error: '',\n                            basename: basename,\n                            subtitles: undefined,\n                        },\n                    }));\n                }\n            });\n            const ready = () => (!waitForBasename || basename !== '') && window.location.pathname in subtitlesByPath;\n            if (!ready()) {\n                await poll(ready);\n            }\n            document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n                detail: {\n                    error: '',\n                    basename: basename,\n                    subtitles: subtitlesByPath[window.location.pathname] ?? [],\n                },\n            }));\n            garbageCollect();\n            trackDataRequestHandled = true;\n        }, false);\n    }, 0);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { extractExtension, trackFromDef } from './util';\nsetTimeout(() => {\n    function isObject(val) {\n        return typeof val === 'object' && !Array.isArray(val) && val !== null;\n    }\n    function extractSubtitleTracks(value) {\n        const subtitles = [];\n        if (isObject(value.transcripts_urls?.webvtt)) {\n            const urls = value.transcripts_urls.webvtt;\n            for (const language of Object.keys(urls)) {\n                const url = urls[language];\n                if (typeof url === 'string') {\n                    if (subtitles.find((s) => s.label === s.language) === undefined) {\n                        subtitles.push(trackFromDef({\n                            label: language,\n                            language: language.toLowerCase(),\n                            url: url,\n                            extension: extractExtension(url, 'vtt'),\n                        }));\n                    }\n                }\n            }\n        }\n        return subtitles;\n    }\n    let playlistController;\n    function fetchPlaylistAndExtractSubtitles(payload) {\n        playlistController?.abort();\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n                playlistController?.abort();\n                playlistController = new AbortController();\n                fetch('https://play.hulu.com/v6/playlist', {\n                    method: 'POST',\n                    credentials: 'include',\n                    headers: { 'content-type': 'application/json' },\n                    body: payload,\n                    signal: playlistController.signal,\n                })\n                    .then((response) => response.json())\n                    .then((json) => resolve(extractSubtitleTracks(json)))\n                    .catch(reject);\n            }, 0);\n        });\n    }\n    function extractBasename(payload) {\n        if (payload?.items instanceof Array && payload.items.length > 0) {\n            const item = payload.items[0];\n            if (item.series_name && item.season_short_display_name && item.number && item.name) {\n                return `${item.series_name}.${item.season_short_display_name}.E${item.number} - ${item.name}`;\n            }\n            return item.name ?? '';\n        }\n        return '';\n    }\n    let upnextController;\n    function fetchUpNextAndExtractBasename(eabId) {\n        upnextController?.abort();\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n                upnextController?.abort();\n                upnextController = new AbortController();\n                fetch(`https://discover.hulu.com/content/v3/browse/upnext?current_eab=${encodeURIComponent(eabId)}&referral_host=www.hulu.com&schema=4`, { signal: upnextController.signal })\n                    .then((response) => response.json())\n                    .then((json) => resolve(extractBasename(json)))\n                    .catch(reject);\n            }, 0);\n        });\n    }\n    let subtitlesPromise;\n    let basenamePromise;\n    const originalStringify = JSON.stringify;\n    JSON.stringify = function (value) {\n        // @ts-ignore\n        const stringified = originalStringify.apply(this, arguments);\n        if (typeof value?.content_eab_id === 'string' &&\n            typeof value?.playback === 'object' &&\n            value?.playback !== null) {\n            subtitlesPromise = fetchPlaylistAndExtractSubtitles(stringified);\n            basenamePromise = fetchUpNextAndExtractBasename(value.content_eab_id);\n        }\n        return stringified;\n    };\n    document.addEventListener('asbplayer-get-synced-data', async () => {\n        let basename = '';\n        let subtitles = [];\n        let error = '';\n        try {\n            if (basenamePromise !== undefined) {\n                basename = await basenamePromise;\n                basenamePromise = undefined;\n            }\n            if (subtitlesPromise !== undefined) {\n                subtitles = await subtitlesPromise;\n                subtitlesPromise = undefined;\n            }\n        }\n        catch (e) {\n            if (e instanceof Error) {\n                error = e.message;\n            }\n            else {\n                error = String(e);\n            }\n        }\n        const response = {\n            error: error,\n            basename: basename,\n            subtitles: subtitles,\n        };\n        document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n            detail: response,\n        }));\n    }, false);\n}, 0);\n"],"names":["extractExtension","url","fallback","dotIndex","lastIndexOf","extension","substring","questionMarkIndex","indexOf","trackFromDef","def","id","trackId","language","label","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","setTimeout","playlistController","upnextController","subtitlesPromise","basenamePromise","originalStringify","JSON","stringify","value","stringified","apply","this","arguments","payload","eabId","content_eab_id","playback","abort","Promise","resolve","reject","AbortController","fetch","method","credentials","headers","body","signal","then","response","json","subtitles","val","transcripts_urls","webvtt","Array","isArray","urls","keys","find","s","push","toLowerCase","extractSubtitleTracks","catch","encodeURIComponent","items","length","item","series_name","season_short_display_name","number","name","extractBasename","document","addEventListener","async","basename","error","e","Error","message","String","dispatchEvent","CustomEvent","detail"],"sourceRoot":""}