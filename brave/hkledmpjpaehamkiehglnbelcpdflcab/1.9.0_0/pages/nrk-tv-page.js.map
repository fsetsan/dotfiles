{"version":3,"file":"/pages/nrk-tv-page.js","mappings":"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","sources":["webpack://@project/extension/./src/pages/util.ts","webpack://@project/extension/webpack/bootstrap","webpack://@project/extension/webpack/runtime/define property getters","webpack://@project/extension/webpack/runtime/hasOwnProperty shorthand","webpack://@project/extension/./src/pages/nrk-tv-page.ts"],"sourcesContent":["export function extractExtension(url, fallback) {\n    const dotIndex = url.lastIndexOf('.');\n    let extension = fallback;\n    if (dotIndex !== -1) {\n        extension = url.substring(dotIndex + 1);\n        // Account for case when URL has a query parameter\n        const questionMarkIndex = extension.indexOf('?');\n        if (questionMarkIndex !== -1) {\n            extension = extension.substring(0, questionMarkIndex);\n        }\n    }\n    return extension;\n}\nexport function poll(test, timeout = 10000) {\n    return new Promise(async (resolve, reject) => {\n        if (test()) {\n            resolve(true);\n        }\n        const t0 = Date.now();\n        let passed = false;\n        while (!passed && Date.now() < t0 + timeout) {\n            await new Promise((loopResolve) => {\n                setTimeout(() => {\n                    passed = test();\n                    loopResolve();\n                }, 1000);\n            });\n        }\n        resolve(passed);\n    });\n}\nexport const trackFromDef = (def) => {\n    return { id: trackId(def), ...def };\n};\nexport const trackId = (def) => {\n    return `${def.language}:${def.label}:${def.url}`;\n};\nexport function inferTracks({ onJson, onRequest, waitForBasename }) {\n    setTimeout(() => {\n        const subtitlesByPath = {};\n        let basename = '';\n        let trackDataRequestHandled = false;\n        if (onJson !== undefined) {\n            const originalParse = JSON.parse;\n            JSON.parse = function () {\n                // @ts-ignore\n                const value = originalParse.apply(this, arguments);\n                let tracksFound = false;\n                let basenameFound = false;\n                onJson?.(value, (track) => {\n                    const path = window.location.pathname;\n                    if (typeof subtitlesByPath[path] === 'undefined') {\n                        subtitlesByPath[path] = [];\n                    }\n                    const newId = trackId(track);\n                    if (subtitlesByPath[path].find((s) => s.id === newId) === undefined) {\n                        subtitlesByPath[path].push({ id: newId, ...track });\n                        tracksFound = true;\n                    }\n                }, (theBasename) => {\n                    basename = theBasename;\n                    basenameFound = true;\n                });\n                if (trackDataRequestHandled && (tracksFound || basenameFound)) {\n                    // Only notify additional tracks after the initial request for track info\n                    document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n                        detail: {\n                            error: '',\n                            basename: basename,\n                            subtitles: subtitlesByPath[window.location.pathname],\n                        },\n                    }));\n                }\n                return value;\n            };\n        }\n        function garbageCollect() {\n            for (const path of Object.keys(subtitlesByPath)) {\n                if (path !== window.location.pathname) {\n                    delete subtitlesByPath[path];\n                }\n            }\n        }\n        document.addEventListener('asbplayer-get-synced-data', async () => {\n            onRequest?.((track) => {\n                const path = window.location.pathname;\n                if (typeof subtitlesByPath[path] === 'undefined') {\n                    subtitlesByPath[path] = [];\n                }\n                const newId = trackId(track);\n                if (subtitlesByPath[path].find((s) => s.id === newId) === undefined) {\n                    subtitlesByPath[path].push({ id: newId, ...track });\n                }\n            }, (theBasename) => {\n                basename = theBasename;\n                if (!trackDataRequestHandled) {\n                    // Notify basename even if still waiting for subtitle track info\n                    document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n                        detail: {\n                            error: '',\n                            basename: basename,\n                            subtitles: undefined,\n                        },\n                    }));\n                }\n            });\n            const ready = () => (!waitForBasename || basename !== '') && window.location.pathname in subtitlesByPath;\n            if (!ready()) {\n                await poll(ready);\n            }\n            document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n                detail: {\n                    error: '',\n                    basename: basename,\n                    subtitles: subtitlesByPath[window.location.pathname] ?? [],\n                },\n            }));\n            garbageCollect();\n            trackDataRequestHandled = true;\n        }, false);\n    }, 0);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { inferTracks } from './util';\nconst originalFetch = window.fetch;\nlet lastMetadataUrl;\nwindow.fetch = (...args) => {\n    let metadataUrl = undefined;\n    for (const arg of args) {\n        if (typeof arg === 'string' && arg.includes('metadata')) {\n            metadataUrl = arg;\n        }\n        if (arg instanceof Request && arg.url.includes('metadata')) {\n            metadataUrl = arg.url;\n        }\n    }\n    if (metadataUrl !== undefined) {\n        lastMetadataUrl = metadataUrl;\n    }\n    return originalFetch(...args);\n};\nconst requestTracks = async (url) => {\n    const tracks = [];\n    try {\n        const value = await (await fetch(url)).json();\n        if (typeof value?.playable?.subtitles === 'object' && Array.isArray(value.playable.subtitles)) {\n            for (const track of value.playable.subtitles) {\n                if (typeof track.label === 'string' &&\n                    typeof track.language === 'string' &&\n                    typeof track.webVtt === 'string') {\n                    tracks.push({\n                        label: track.label,\n                        language: track.language,\n                        url: track.webVtt,\n                        extension: 'vtt',\n                    });\n                }\n            }\n        }\n    }\n    catch (e) {\n        console.error(e);\n    }\n    return tracks;\n};\ninferTracks({\n    onRequest: async (addTrack, setBasename) => {\n        if (lastMetadataUrl === undefined) {\n            return;\n        }\n        const manifestUrl = new URL(lastMetadataUrl);\n        const value = await (await fetch(lastMetadataUrl)).json();\n        if (typeof value?.preplay?.titles?.title === 'string') {\n            if (typeof value?.preplay?.titles?.subtitle === 'string') {\n                setBasename(`${value.preplay.titles.title} ${value.preplay.titles.subtitle}`);\n            }\n            else {\n                setBasename(value.preplay.titles.title);\n            }\n        }\n        if (typeof value?._links?.manifests === 'object' && Array.isArray(value._links.manifests)) {\n            for (const manifest of value._links.manifests) {\n                if (typeof manifest.href === 'string') {\n                    const tracks = await requestTracks(`${manifestUrl.origin}${manifest.href}`);\n                    for (const track of tracks) {\n                        addTrack(track);\n                    }\n                }\n            }\n        }\n    },\n    waitForBasename: true,\n});\n"],"names":["trackId","def","language","label","url","inferTracks","onJson","onRequest","waitForBasename","setTimeout","subtitlesByPath","basename","trackDataRequestHandled","undefined","originalParse","JSON","parse","value","apply","this","arguments","tracksFound","basenameFound","track","path","window","location","pathname","newId","find","s","id","push","theBasename","document","dispatchEvent","CustomEvent","detail","error","subtitles","addEventListener","async","ready","test","timeout","Promise","resolve","reject","t0","Date","now","passed","loopResolve","poll","Object","keys","garbageCollect","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","d","definition","key","o","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","originalFetch","fetch","lastMetadataUrl","args","metadataUrl","arg","includes","Request","requestTracks","tracks","json","playable","Array","isArray","webVtt","extension","e","console","addTrack","setBasename","manifestUrl","URL","preplay","titles","title","subtitle","_links","manifests","manifest","href","origin"],"sourceRoot":""}