{"version":3,"file":"/pages/plex-page.js","mappings":"2DA+BO,MAAMA,EAAgBC,IAClB,CAAEC,GAAIC,EAAQF,MAASA,IAErBE,EAAWF,GACb,GAAGA,EAAIG,YAAYH,EAAII,SAASJ,EAAIK,K,GClC3CC,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAaE,QAGrB,IAAIC,EAASN,EAAyBE,GAAY,CAGjDG,QAAS,CAAC,GAOX,OAHAE,EAAoBL,GAAUI,EAAQA,EAAOD,QAASJ,GAG/CK,EAAOD,OACf,CCrBAJ,EAAoBO,EAAI,CAACH,EAASI,KACjC,IAAI,IAAIC,KAAOD,EACXR,EAAoBU,EAAEF,EAAYC,KAAST,EAAoBU,EAAEN,EAASK,IAC5EE,OAAOC,eAAeR,EAASK,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDT,EAAoBU,EAAI,CAACK,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,G,oBCClF,IAAII,EACAC,EACAC,EACAC,EACJ,MAAMC,EAAgBC,OAAOC,MAC7BD,OAAOC,MAAQ,IAAIC,KACf,IAAK,MAAMC,KAAOD,EAAM,CACpB,MAAM7B,EAAqB,iBAAR8B,EAAmBA,EAAMA,aAAeC,QAAUD,EAAI9B,IAAM,KAC/E,IAAKA,EACD,SAEJ,IAAKuB,EAAW,CACZ,MAAMS,EAAahC,EAAIiC,MAAM,yBACzBD,IACAV,EAAY,IAAIY,IAAIlC,GAAKmC,OACzBZ,EAAYS,EAAW,GAE/B,CACA,IAAII,EAAiBpC,EAAIiC,MAAM,+BAC3BG,IACAZ,EAAYY,EAAe,IAE/BA,EAAiBpC,EAAIiC,MAAM,oBACvBG,IACAZ,EAAYY,EAAe,IAE/B,MAAMC,EAAsBrC,EAAIiC,MAAM,kCAClCI,IACAZ,EAAiBzB,EAAIsC,QAAQD,EAAoB,GAAI,mCAE7D,CACA,OAAOX,KAAiBG,EAAK,EAEjCU,SAASC,iBAAiB,6BAA6BC,UACnD,MAAMC,EAAW,CAAEC,MAAO,GAAIC,SAAU,GAAIC,UAAW,IACjDC,EAAiB,8KAEjBC,EAAS,IAAIC,UACnB,IAAK1B,IAAcC,EAEf,OADAmB,EAASC,MAAQ,+CAA+CG,IACzDP,SAASU,cAAc,IAAIC,YAAY,wBAAyB,CACnEC,OAAQT,KAGhB,IAAKlB,EAED,OADAkB,EAASC,MAAQ,mDAAmDG,IAC7DP,SAASU,cAAc,IAAIC,YAAY,wBAAyB,CACnEC,OAAQT,KAGhB,MAAMU,QAAgBxB,MAAM,GAAGN,sBAA8BE,kBAA0BD,KACjF8B,QAAgBD,EAAQE,OAExBC,EADSR,EAAOS,gBAAgBH,EAAS,mBACvBI,cAAc,SACtC,IAAKF,EAED,OADAb,EAASC,MAAQ,qCAAqCG,MAAmBO,IAClEd,SAASU,cAAc,IAAIC,YAAY,wBAAyB,CACnEC,OAAQT,KAGhBA,EAASE,SAAWW,EAASG,aAAa,UAAY,UACtD,MAAMb,EAAY,GACJU,EAASI,iBAAiB,QAClCC,SAASC,IACKA,EAAKF,iBAAiB,0BAC9BC,SAASE,IACb,MAAMC,EAAYD,EAAOJ,aAAa,OAClCK,EAEAlB,EAAUmB,MAAK,QAAa,CACxBjE,MAAO+D,EAAOJ,aAAa,yBAA2B,GACtD5D,SAAUgE,EAAOJ,aAAa,aAAe,GAC7C1D,IAAK,GAAGsB,IAAYyC,kBAA0BxC,IAC9C0C,UAAWH,EAAOJ,aAAa,UAAY,MAInDhB,EAASC,MAAQ,0IAA0I,GAmB7J,IAEND,EAASG,UAAYA,EACrBN,SAASU,cAAc,IAAIC,YAAY,wBAAyB,CAC5DC,OAAQT,IACT,IACJ,E","sources":["webpack://@project/extension/./src/pages/util.ts","webpack://@project/extension/webpack/bootstrap","webpack://@project/extension/webpack/runtime/define property getters","webpack://@project/extension/webpack/runtime/hasOwnProperty shorthand","webpack://@project/extension/./src/pages/plex-page.ts"],"sourcesContent":["export function extractExtension(url, fallback) {\n    const dotIndex = url.lastIndexOf('.');\n    let extension = fallback;\n    if (dotIndex !== -1) {\n        extension = url.substring(dotIndex + 1);\n        // Account for case when URL has a query parameter\n        const questionMarkIndex = extension.indexOf('?');\n        if (questionMarkIndex !== -1) {\n            extension = extension.substring(0, questionMarkIndex);\n        }\n    }\n    return extension;\n}\nexport function poll(test, timeout = 10000) {\n    return new Promise(async (resolve, reject) => {\n        if (test()) {\n            resolve(true);\n        }\n        const t0 = Date.now();\n        let passed = false;\n        while (!passed && Date.now() < t0 + timeout) {\n            await new Promise((loopResolve) => {\n                setTimeout(() => {\n                    passed = test();\n                    loopResolve();\n                }, 1000);\n            });\n        }\n        resolve(passed);\n    });\n}\nexport const trackFromDef = (def) => {\n    return { id: trackId(def), ...def };\n};\nexport const trackId = (def) => {\n    return `${def.language}:${def.label}:${def.url}`;\n};\nexport function inferTracks({ onJson, onRequest, waitForBasename }) {\n    setTimeout(() => {\n        const subtitlesByPath = {};\n        let basename = '';\n        let trackDataRequestHandled = false;\n        if (onJson !== undefined) {\n            const originalParse = JSON.parse;\n            JSON.parse = function () {\n                // @ts-ignore\n                const value = originalParse.apply(this, arguments);\n                let tracksFound = false;\n                let basenameFound = false;\n                onJson?.(value, (track) => {\n                    const path = window.location.pathname;\n                    if (typeof subtitlesByPath[path] === 'undefined') {\n                        subtitlesByPath[path] = [];\n                    }\n                    const newId = trackId(track);\n                    if (subtitlesByPath[path].find((s) => s.id === newId) === undefined) {\n                        subtitlesByPath[path].push({ id: newId, ...track });\n                        tracksFound = true;\n                    }\n                }, (theBasename) => {\n                    basename = theBasename;\n                    basenameFound = true;\n                });\n                if (trackDataRequestHandled && (tracksFound || basenameFound)) {\n                    // Only notify additional tracks after the initial request for track info\n                    document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n                        detail: {\n                            error: '',\n                            basename: basename,\n                            subtitles: subtitlesByPath[window.location.pathname],\n                        },\n                    }));\n                }\n                return value;\n            };\n        }\n        function garbageCollect() {\n            for (const path of Object.keys(subtitlesByPath)) {\n                if (path !== window.location.pathname) {\n                    delete subtitlesByPath[path];\n                }\n            }\n        }\n        document.addEventListener('asbplayer-get-synced-data', async () => {\n            onRequest?.((track) => {\n                const path = window.location.pathname;\n                if (typeof subtitlesByPath[path] === 'undefined') {\n                    subtitlesByPath[path] = [];\n                }\n                const newId = trackId(track);\n                if (subtitlesByPath[path].find((s) => s.id === newId) === undefined) {\n                    subtitlesByPath[path].push({ id: newId, ...track });\n                }\n            }, (theBasename) => {\n                basename = theBasename;\n                if (!trackDataRequestHandled) {\n                    // Notify basename even if still waiting for subtitle track info\n                    document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n                        detail: {\n                            error: '',\n                            basename: basename,\n                            subtitles: undefined,\n                        },\n                    }));\n                }\n            });\n            const ready = () => (!waitForBasename || basename !== '') && window.location.pathname in subtitlesByPath;\n            if (!ready()) {\n                await poll(ready);\n            }\n            document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n                detail: {\n                    error: '',\n                    basename: basename,\n                    subtitles: subtitlesByPath[window.location.pathname] ?? [],\n                },\n            }));\n            garbageCollect();\n            trackDataRequestHandled = true;\n        }, false);\n    }, 0);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { trackFromDef } from './util';\nlet serverUrl;\nlet plexToken;\nlet ratingKey; // Unique identifier for the video\nlet selectedSubUrl; // URL to stream current subtitle\nconst originalFetch = window.fetch;\nwindow.fetch = (...args) => {\n    for (const arg of args) {\n        const url = typeof arg === 'string' ? arg : arg instanceof Request ? arg.url : null;\n        if (!url) {\n            continue;\n        }\n        if (!plexToken) {\n            const tokenMatch = url.match(/X-Plex-Token=([^&]+)/i);\n            if (tokenMatch) {\n                serverUrl = new URL(url).origin;\n                plexToken = tokenMatch[1];\n            }\n        }\n        let ratingKeyMatch = url.match(/library%2Fmetadata%2F(\\d+)/i);\n        if (ratingKeyMatch) {\n            ratingKey = ratingKeyMatch[1];\n        }\n        ratingKeyMatch = url.match(/ratingKey=(\\d+)/i);\n        if (ratingKeyMatch) {\n            ratingKey = ratingKeyMatch[1];\n        }\n        const selectedSubUrlMatch = url.match(/\\/transcode\\/universal\\/.+?\\?/i);\n        if (selectedSubUrlMatch) {\n            selectedSubUrl = url.replace(selectedSubUrlMatch[0], '/transcode/universal/subtitles?');\n        }\n    }\n    return originalFetch(...args);\n};\ndocument.addEventListener('asbplayer-get-synced-data', async () => {\n    const response = { error: '', basename: '', subtitles: [] };\n    const miniPlayerWarn = 'Automatic detection does not work for Plex if you resume playing your previous session from the mini player. Try stopping the video and hitting play on the media directly.';\n    const internalSubWarn = 'Internal subtitles must be currently selected for automatic detection. You can unselect it on the Plex player after asbplayer has it loaded. It also must not be burned in, set \"Only image formats\" for \"Burn Subtitles\" in Plex Settings > Player.';\n    const parser = new DOMParser();\n    if (!serverUrl || !plexToken) {\n        response.error = `Could not get the Plex server URL or token. ${miniPlayerWarn}`;\n        return document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n            detail: response,\n        }));\n    }\n    if (!ratingKey) {\n        response.error = `Could not get the ratingKey for the Plex media. ${miniPlayerWarn}`;\n        return document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n            detail: response,\n        }));\n    }\n    const resMeta = await fetch(`${serverUrl}/library/metadata/${ratingKey}?X-Plex-Token=${plexToken}`);\n    const xmlText = await resMeta.text();\n    const xmlDoc = parser.parseFromString(xmlText, 'application/xml');\n    const metadata = xmlDoc.querySelector('Video');\n    if (!metadata) {\n        response.error = `No metadata found for Plex video. ${miniPlayerWarn}: ${xmlText}`;\n        return document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n            detail: response,\n        }));\n    }\n    response.basename = metadata.getAttribute('title') ?? 'Unknown';\n    const subtitles = [];\n    const parts = metadata.querySelectorAll('Part');\n    parts.forEach((part) => {\n        const streams = part.querySelectorAll('Stream[streamType=\"3\"]');\n        streams.forEach((stream) => {\n            const streamKey = stream.getAttribute('key');\n            if (streamKey) {\n                // Only external can be downloaded directly\n                subtitles.push(trackFromDef({\n                    label: stream.getAttribute('extendedDisplayTitle') ?? '',\n                    language: stream.getAttribute('language') ?? '',\n                    url: `${serverUrl}${streamKey}?X-Plex-Token=${plexToken}`,\n                    extension: stream.getAttribute('codec') ?? '',\n                }));\n                return;\n            }\n            response.error = `Automatic detection is only available for external subtitles on Plex. If none are available, try Plex's subtitle search or use your own.`;\n            // if (stream.getAttribute('selected') === '1') {\n            //     if (!selectedSubUrl) {\n            //         response.error = `Could not get trancoding url for internal subtitle. ${internalSubWarn}`;\n            //         return;\n            //     }\n            //     subtitles.push(\n            //         trackFromDef({\n            //             label: stream.getAttribute('extendedDisplayTitle') ?? '',\n            //             language: stream.getAttribute('language') ?? '',\n            //             url: selectedSubUrl,\n            //             extension: stream.getAttribute('codec') ?? '',\n            //         })\n            //     );\n            //     return;\n            // }\n            // if (!response.error) {\n            //     response.error = internalSubWarn;\n            // }\n        });\n    });\n    response.subtitles = subtitles;\n    document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n        detail: response,\n    }));\n}, false);\n"],"names":["trackFromDef","def","id","trackId","language","label","url","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","serverUrl","plexToken","ratingKey","selectedSubUrl","originalFetch","window","fetch","args","arg","Request","tokenMatch","match","URL","origin","ratingKeyMatch","selectedSubUrlMatch","replace","document","addEventListener","async","response","error","basename","subtitles","miniPlayerWarn","parser","DOMParser","dispatchEvent","CustomEvent","detail","resMeta","xmlText","text","metadata","parseFromString","querySelector","getAttribute","querySelectorAll","forEach","part","stream","streamKey","push","extension"],"sourceRoot":""}