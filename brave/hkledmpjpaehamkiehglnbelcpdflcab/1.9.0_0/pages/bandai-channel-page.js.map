{"version":3,"file":"/pages/bandai-channel-page.js","mappings":"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","sources":["webpack://@project/extension/./src/pages/util.ts","webpack://@project/extension/webpack/bootstrap","webpack://@project/extension/webpack/runtime/define property getters","webpack://@project/extension/webpack/runtime/hasOwnProperty shorthand","webpack://@project/extension/./src/pages/bandai-channel-page.ts"],"sourcesContent":["export function extractExtension(url, fallback) {\n    const dotIndex = url.lastIndexOf('.');\n    let extension = fallback;\n    if (dotIndex !== -1) {\n        extension = url.substring(dotIndex + 1);\n        // Account for case when URL has a query parameter\n        const questionMarkIndex = extension.indexOf('?');\n        if (questionMarkIndex !== -1) {\n            extension = extension.substring(0, questionMarkIndex);\n        }\n    }\n    return extension;\n}\nexport function poll(test, timeout = 10000) {\n    return new Promise(async (resolve, reject) => {\n        if (test()) {\n            resolve(true);\n        }\n        const t0 = Date.now();\n        let passed = false;\n        while (!passed && Date.now() < t0 + timeout) {\n            await new Promise((loopResolve) => {\n                setTimeout(() => {\n                    passed = test();\n                    loopResolve();\n                }, 1000);\n            });\n        }\n        resolve(passed);\n    });\n}\nexport const trackFromDef = (def) => {\n    return { id: trackId(def), ...def };\n};\nexport const trackId = (def) => {\n    return `${def.language}:${def.label}:${def.url}`;\n};\nexport function inferTracks({ onJson, onRequest, waitForBasename }) {\n    setTimeout(() => {\n        const subtitlesByPath = {};\n        let basename = '';\n        let trackDataRequestHandled = false;\n        if (onJson !== undefined) {\n            const originalParse = JSON.parse;\n            JSON.parse = function () {\n                // @ts-ignore\n                const value = originalParse.apply(this, arguments);\n                let tracksFound = false;\n                let basenameFound = false;\n                onJson?.(value, (track) => {\n                    const path = window.location.pathname;\n                    if (typeof subtitlesByPath[path] === 'undefined') {\n                        subtitlesByPath[path] = [];\n                    }\n                    const newId = trackId(track);\n                    if (subtitlesByPath[path].find((s) => s.id === newId) === undefined) {\n                        subtitlesByPath[path].push({ id: newId, ...track });\n                        tracksFound = true;\n                    }\n                }, (theBasename) => {\n                    basename = theBasename;\n                    basenameFound = true;\n                });\n                if (trackDataRequestHandled && (tracksFound || basenameFound)) {\n                    // Only notify additional tracks after the initial request for track info\n                    document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n                        detail: {\n                            error: '',\n                            basename: basename,\n                            subtitles: subtitlesByPath[window.location.pathname],\n                        },\n                    }));\n                }\n                return value;\n            };\n        }\n        function garbageCollect() {\n            for (const path of Object.keys(subtitlesByPath)) {\n                if (path !== window.location.pathname) {\n                    delete subtitlesByPath[path];\n                }\n            }\n        }\n        document.addEventListener('asbplayer-get-synced-data', async () => {\n            onRequest?.((track) => {\n                const path = window.location.pathname;\n                if (typeof subtitlesByPath[path] === 'undefined') {\n                    subtitlesByPath[path] = [];\n                }\n                const newId = trackId(track);\n                if (subtitlesByPath[path].find((s) => s.id === newId) === undefined) {\n                    subtitlesByPath[path].push({ id: newId, ...track });\n                }\n            }, (theBasename) => {\n                basename = theBasename;\n                if (!trackDataRequestHandled) {\n                    // Notify basename even if still waiting for subtitle track info\n                    document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n                        detail: {\n                            error: '',\n                            basename: basename,\n                            subtitles: undefined,\n                        },\n                    }));\n                }\n            });\n            const ready = () => (!waitForBasename || basename !== '') && window.location.pathname in subtitlesByPath;\n            if (!ready()) {\n                await poll(ready);\n            }\n            document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n                detail: {\n                    error: '',\n                    basename: basename,\n                    subtitles: subtitlesByPath[window.location.pathname] ?? [],\n                },\n            }));\n            garbageCollect();\n            trackDataRequestHandled = true;\n        }, false);\n    }, 0);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { extractExtension, inferTracks, poll } from './util';\nfunction basenameFromDOM() {\n    const seriesElement = document.getElementById('bch-series-title');\n    const episodeElement = document.getElementById('bch-story-title');\n    if (!seriesElement || !episodeElement) {\n        return undefined;\n    }\n    if (!seriesElement.textContent) {\n        return undefined;\n    }\n    if (!episodeElement.childNodes || episodeElement.childNodes.length === 0) {\n        return undefined;\n    }\n    return `${seriesElement.textContent} ${episodeElement.childNodes[0].nodeValue}`;\n}\ninferTracks({\n    onJson: (value, addTrack, setBasename) => {\n        let basename;\n        if (value?.bc?.text_tracks instanceof Array) {\n            for (const track of value.bc.text_tracks) {\n                if (track.kind === 'subtitles' &&\n                    track.mime_type === 'text/webvtt' &&\n                    track.sources instanceof Array &&\n                    track.sources.length > 0 &&\n                    typeof track.sources[0].src === 'string' &&\n                    typeof track.srclang === 'string') {\n                    const label = typeof track.label === 'string' ? `${track.srclang} - ${track?.label}` : track.srclang;\n                    const url = track.sources[0].src.replace(/^http:\\/\\//, 'https://');\n                    addTrack({\n                        label: label,\n                        language: track.srclang.toLowerCase(),\n                        url: url,\n                        extension: extractExtension(url, 'vtt'),\n                    });\n                }\n            }\n            if (typeof value.bc.name === 'string') {\n                basename = value.bc.name;\n                setBasename(value.bc.name);\n            }\n        }\n        if (basename === undefined && typeof value?.bch?.episode_title === 'string') {\n            basename = value.bch.episode_title;\n            setBasename(value.bch.episode_title);\n        }\n    },\n    onRequest: async (addTrack, setBasename) => {\n        const succeeded = await poll(() => {\n            const basename = basenameFromDOM();\n            if (basename) {\n                setBasename(basename);\n                return true;\n            }\n            return false;\n        });\n        if (!succeeded) {\n            setBasename(document.title);\n        }\n    },\n    waitForBasename: true,\n});\n"],"names":["extractExtension","url","fallback","dotIndex","lastIndexOf","extension","substring","questionMarkIndex","indexOf","poll","test","timeout","Promise","async","resolve","reject","t0","Date","now","passed","loopResolve","setTimeout","trackId","def","language","label","inferTracks","onJson","onRequest","waitForBasename","subtitlesByPath","basename","trackDataRequestHandled","undefined","originalParse","JSON","parse","value","apply","this","arguments","tracksFound","basenameFound","track","path","window","location","pathname","newId","find","s","id","push","theBasename","document","dispatchEvent","CustomEvent","detail","error","subtitles","addEventListener","ready","Object","keys","garbageCollect","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","d","definition","key","o","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","addTrack","setBasename","bc","text_tracks","Array","kind","mime_type","sources","length","src","srclang","replace","toLowerCase","name","bch","episode_title","seriesElement","getElementById","episodeElement","textContent","childNodes","nodeValue","basenameFromDOM","title"],"sourceRoot":""}