{"version":3,"file":"/pages/netflix-page.js","mappings":"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","sources":["webpack://@project/extension/./src/pages/util.ts","webpack://@project/extension/webpack/bootstrap","webpack://@project/extension/webpack/runtime/define property getters","webpack://@project/extension/webpack/runtime/hasOwnProperty shorthand","webpack://@project/extension/./src/pages/netflix-page.ts"],"sourcesContent":["export function extractExtension(url, fallback) {\n    const dotIndex = url.lastIndexOf('.');\n    let extension = fallback;\n    if (dotIndex !== -1) {\n        extension = url.substring(dotIndex + 1);\n        // Account for case when URL has a query parameter\n        const questionMarkIndex = extension.indexOf('?');\n        if (questionMarkIndex !== -1) {\n            extension = extension.substring(0, questionMarkIndex);\n        }\n    }\n    return extension;\n}\nexport function poll(test, timeout = 10000) {\n    return new Promise(async (resolve, reject) => {\n        if (test()) {\n            resolve(true);\n        }\n        const t0 = Date.now();\n        let passed = false;\n        while (!passed && Date.now() < t0 + timeout) {\n            await new Promise((loopResolve) => {\n                setTimeout(() => {\n                    passed = test();\n                    loopResolve();\n                }, 1000);\n            });\n        }\n        resolve(passed);\n    });\n}\nexport const trackFromDef = (def) => {\n    return { id: trackId(def), ...def };\n};\nexport const trackId = (def) => {\n    return `${def.language}:${def.label}:${def.url}`;\n};\nexport function inferTracks({ onJson, onRequest, waitForBasename }) {\n    setTimeout(() => {\n        const subtitlesByPath = {};\n        let basename = '';\n        let trackDataRequestHandled = false;\n        if (onJson !== undefined) {\n            const originalParse = JSON.parse;\n            JSON.parse = function () {\n                // @ts-ignore\n                const value = originalParse.apply(this, arguments);\n                let tracksFound = false;\n                let basenameFound = false;\n                onJson?.(value, (track) => {\n                    const path = window.location.pathname;\n                    if (typeof subtitlesByPath[path] === 'undefined') {\n                        subtitlesByPath[path] = [];\n                    }\n                    const newId = trackId(track);\n                    if (subtitlesByPath[path].find((s) => s.id === newId) === undefined) {\n                        subtitlesByPath[path].push({ id: newId, ...track });\n                        tracksFound = true;\n                    }\n                }, (theBasename) => {\n                    basename = theBasename;\n                    basenameFound = true;\n                });\n                if (trackDataRequestHandled && (tracksFound || basenameFound)) {\n                    // Only notify additional tracks after the initial request for track info\n                    document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n                        detail: {\n                            error: '',\n                            basename: basename,\n                            subtitles: subtitlesByPath[window.location.pathname],\n                        },\n                    }));\n                }\n                return value;\n            };\n        }\n        function garbageCollect() {\n            for (const path of Object.keys(subtitlesByPath)) {\n                if (path !== window.location.pathname) {\n                    delete subtitlesByPath[path];\n                }\n            }\n        }\n        document.addEventListener('asbplayer-get-synced-data', async () => {\n            onRequest?.((track) => {\n                const path = window.location.pathname;\n                if (typeof subtitlesByPath[path] === 'undefined') {\n                    subtitlesByPath[path] = [];\n                }\n                const newId = trackId(track);\n                if (subtitlesByPath[path].find((s) => s.id === newId) === undefined) {\n                    subtitlesByPath[path].push({ id: newId, ...track });\n                }\n            }, (theBasename) => {\n                basename = theBasename;\n                if (!trackDataRequestHandled) {\n                    // Notify basename even if still waiting for subtitle track info\n                    document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n                        detail: {\n                            error: '',\n                            basename: basename,\n                            subtitles: undefined,\n                        },\n                    }));\n                }\n            });\n            const ready = () => (!waitForBasename || basename !== '') && window.location.pathname in subtitlesByPath;\n            if (!ready()) {\n                await poll(ready);\n            }\n            document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n                detail: {\n                    error: '',\n                    basename: basename,\n                    subtitles: subtitlesByPath[window.location.pathname] ?? [],\n                },\n            }));\n            garbageCollect();\n            trackDataRequestHandled = true;\n        }, false);\n    }, 0);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { poll, trackFromDef } from './util';\nsetTimeout(() => {\n    const webvtt = 'webvtt-lssdh-ios8';\n    const manifestPattern = new RegExp('manifest|licensedManifest');\n    const subTracks = new Map();\n    function getAPI() {\n        if (typeof netflix === 'undefined') {\n            return undefined;\n        }\n        return netflix?.appContext?.state?.playerApp?.getAPI?.();\n    }\n    function getVideoPlayer() {\n        return getAPI()?.videoPlayer;\n    }\n    function player() {\n        const netflixVideo = getVideoPlayer();\n        if (netflixVideo) {\n            const playerSessionIds = netflixVideo.getAllPlayerSessionIds?.() || [];\n            if (0 === playerSessionIds.length) {\n                console.error('No Netflix player session IDs');\n                return undefined;\n            }\n            const playerSessionId = playerSessionIds[playerSessionIds.length - 1];\n            return netflixVideo.getVideoPlayerBySessionId?.(playerSessionId);\n        }\n        console.error('Missing netflix global');\n        return undefined;\n    }\n    function extractUrlLegacy(track) {\n        if (track.isForcedNarrative || track.isNoneTrack || !track.cdnlist?.length || !track.ttDownloadables) {\n            return undefined;\n        }\n        const webvttDL = track.ttDownloadables[webvtt];\n        if (!webvttDL?.downloadUrls) {\n            return undefined;\n        }\n        return webvttDL.downloadUrls[track.cdnlist.find((cdn) => webvttDL.downloadUrls[cdn.id])?.id];\n    }\n    function extractUrl(track) {\n        if (track.isForcedNarrative || track.isNoneTrack || !track.ttDownloadables) {\n            return undefined;\n        }\n        const webvttDL = track.ttDownloadables[webvtt];\n        if (!webvttDL?.urls || webvttDL.urls.length === 0) {\n            return 'lazy';\n        }\n        return webvttDL.urls[0].url;\n    }\n    function storeSubTrack(video) {\n        const timedTextracks = video.timedtexttracks || [];\n        for (const track of timedTextracks) {\n            const url = extractUrlLegacy(track) ?? extractUrl(track);\n            if (url === undefined) {\n                continue;\n            }\n            if (!subTracks.has(video.movieId)) {\n                subTracks.set(video.movieId, new Map());\n            }\n            subTracks.get(video.movieId).set(track.new_track_id, url);\n        }\n    }\n    document.addEventListener('asbplayer-netflix-seek', (e) => {\n        player()?.seek(e.detail);\n    });\n    document.addEventListener('asbplayer-netflix-play', () => {\n        player()?.play();\n    });\n    document.addEventListener('asbplayer-netflix-pause', () => {\n        player()?.pause();\n    });\n    function determineBasename(titleId) {\n        const videoApi = getAPI()?.getVideoMetadataByVideoId?.(titleId)?.getCurrentVideo?.();\n        const actualTitle = videoApi?.getTitle?.();\n        if (typeof actualTitle !== 'string') {\n            return [`${titleId}`, true];\n        }\n        let basename = actualTitle;\n        if (videoApi?.isEpisodic?.() === true) {\n            const season = `${videoApi?.getSeason()?._season?.seq}`.padStart(2, '0');\n            const ep = `${videoApi?.getEpisodeNumber?.()}`.padStart(2, '0');\n            const epTitle = videoApi?.getEpisodeTitle?.();\n            basename += ` S${season}E${ep} ${epTitle}`;\n        }\n        return [basename, false];\n    }\n    async function determineBasenameWithRetries(titleId, retries) {\n        if (retries <= 0) {\n            return `${titleId}`;\n        }\n        const [basename, shouldRetry] = determineBasename(titleId);\n        if (shouldRetry) {\n            await new Promise((resolve) => setTimeout(resolve, 1000));\n            return await determineBasenameWithRetries(titleId, --retries);\n        }\n        return basename;\n    }\n    const dataForTrack = (track, storedTracks) => {\n        if (!track.bcp47) {\n            return undefined;\n        }\n        const isClosedCaptions = 'CLOSEDCAPTIONS' === track.rawTrackType;\n        const language = isClosedCaptions ? `${track.bcp47.toLowerCase()}-CC` : track.bcp47.toLowerCase();\n        const label = `${track.bcp47} - ${track.displayName}${isClosedCaptions ? ' [CC]' : ''}`;\n        return trackFromDef({\n            label,\n            language,\n            // 'lazy' is a sentinel value indicating to the content script that it should\n            // make a lazy language-specific request to get the URL\n            url: storedTracks.get(track.trackId) ?? 'lazy',\n            extension: 'nfvtt',\n        });\n    };\n    const buildResponse = async () => {\n        const response = { error: '', basename: '', subtitles: [] };\n        const np = player();\n        const titleId = np?.getMovieId();\n        if (!np || !titleId) {\n            response.error = 'Netflix Player or Title Id not found...';\n            return response;\n        }\n        response.basename = await determineBasenameWithRetries(titleId, 5);\n        const storedTracks = subTracks.get(titleId) || new Map();\n        response.subtitles = np\n            .getTimedTextTrackList()\n            .filter((track) => storedTracks.has(track.trackId))\n            .map((track) => {\n            return dataForTrack(track, storedTracks);\n        })\n            .filter((data) => data !== undefined);\n        return response;\n    };\n    document.addEventListener('asbplayer-get-synced-data', async () => {\n        const response = await buildResponse();\n        document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n            detail: response,\n        }));\n    }, false);\n    const fetchDataForLanguage = async (e) => {\n        const fail = (message) => {\n            document.dispatchEvent(new CustomEvent('asbplayer-synced-language-data', {\n                detail: {\n                    error: message ?? 'Failed to fetch subtitles for requested language',\n                    basename: '',\n                    subtitles: [],\n                },\n            }));\n        };\n        const np = player();\n        if (np === undefined) {\n            fail();\n            return;\n        }\n        const previousTrack = np.getTimedTextTrack();\n        let shouldRevert = false;\n        try {\n            const event = e;\n            const language = event.detail;\n            const storedTracks = subTracks.get(np.getMovieId()) || new Map();\n            const track = np\n                .getTimedTextTrackList()\n                ?.find((track) => dataForTrack(track, storedTracks)?.language === language);\n            if (track === undefined) {\n                fail();\n                return;\n            }\n            const alreadyStoredTrack = storedTracks.get(track.trackId);\n            if (alreadyStoredTrack !== undefined && alreadyStoredTrack !== 'lazy') {\n                // If track is already stored (e.g. from previous request) then\n                // send response now and early-out\n                document.dispatchEvent(new CustomEvent('asbplayer-synced-language-data', {\n                    detail: await buildResponse(),\n                }));\n                return;\n            }\n            // Trigger tracks to be refetched by temporarily setting the text track to the desired language\n            await np.setTimedTextTrack(track);\n            shouldRevert = true;\n            // Wait for the track to appear\n            const succeeded = await poll(() => {\n                const t = storedTracks.get(track.trackId);\n                return t !== undefined && t !== 'lazy';\n            });\n            if (!succeeded) {\n                fail();\n                return;\n            }\n            document.dispatchEvent(new CustomEvent('asbplayer-synced-language-data', {\n                detail: await buildResponse(),\n            }));\n        }\n        catch (e) {\n            fail(e instanceof Error ? e.message : String(e));\n        }\n        finally {\n            if (shouldRevert && previousTrack !== undefined) {\n                await np.setTimedTextTrack(previousTrack);\n            }\n        }\n    };\n    let currentFetchForLanguagePromise;\n    document.addEventListener('asbplayer-get-synced-language-data', \n    // Fetch data for specific language, since Netflix does not provide all URLs in the initial data sync\n    async (e) => {\n        if (currentFetchForLanguagePromise === undefined) {\n            currentFetchForLanguagePromise = fetchDataForLanguage(e);\n        }\n        else {\n            currentFetchForLanguagePromise.then(() => fetchDataForLanguage(e));\n        }\n        await currentFetchForLanguagePromise;\n        currentFetchForLanguagePromise = undefined;\n    }, false);\n    const originalStringify = JSON.stringify;\n    JSON.stringify = function (value) {\n        if ('string' === typeof value?.url && -1 < value.url.search(manifestPattern)) {\n            for (let objectValue of Object.values(value)) {\n                objectValue?.profiles?.unshift(webvtt);\n            }\n        }\n        // @ts-ignore\n        return originalStringify.apply(this, arguments);\n    };\n    const originalParse = JSON.parse;\n    JSON.parse = function () {\n        // @ts-ignore\n        const value = originalParse.apply(this, arguments);\n        if (value?.result?.movieId)\n            storeSubTrack(value.result);\n        return value;\n    };\n    Function.prototype.apply = new Proxy(Function.prototype.apply, {\n        apply: function (target, originalThis, args) {\n            if (args && args[1] && typeof args[1][0] === 'string') {\n                const property = args[1][0];\n                if (property === 'preciseSeeking' ||\n                    property === 'preciseseeking' ||\n                    property === 'preciseseekingontwocoredevice') {\n                    return true;\n                }\n            }\n            // @ts-ignore\n            return target.call(originalThis, ...args);\n        },\n    });\n    document.addEventListener('asbplayer-query-netflix', async () => {\n        const apiAvailable = await poll(() => getVideoPlayer() !== undefined, 30000);\n        document.dispatchEvent(new CustomEvent('asbplayer-netflix-enabled', {\n            detail: apiAvailable,\n        }));\n    });\n}, 0);\n"],"names":["poll","test","timeout","Promise","async","resolve","reject","t0","Date","now","passed","loopResolve","setTimeout","trackFromDef","def","id","trackId","language","label","url","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","webvtt","manifestPattern","RegExp","subTracks","Map","getAPI","netflix","appContext","state","playerApp","getVideoPlayer","videoPlayer","player","netflixVideo","playerSessionIds","getAllPlayerSessionIds","length","console","error","playerSessionId","getVideoPlayerBySessionId","extractUrlLegacy","track","isForcedNarrative","isNoneTrack","cdnlist","ttDownloadables","webvttDL","downloadUrls","find","cdn","extractUrl","urls","determineBasenameWithRetries","titleId","retries","basename","shouldRetry","videoApi","getVideoMetadataByVideoId","getCurrentVideo","actualTitle","getTitle","isEpisodic","season","getSeason","_season","seq","padStart","ep","getEpisodeNumber","epTitle","getEpisodeTitle","determineBasename","document","addEventListener","e","seek","detail","play","pause","dataForTrack","storedTracks","bcp47","isClosedCaptions","rawTrackType","toLowerCase","displayName","extension","buildResponse","response","subtitles","np","getMovieId","getTimedTextTrackList","filter","has","map","data","dispatchEvent","CustomEvent","fetchDataForLanguage","fail","message","previousTrack","getTimedTextTrack","shouldRevert","alreadyStoredTrack","setTimedTextTrack","t","Error","String","currentFetchForLanguagePromise","then","originalStringify","JSON","stringify","value","search","objectValue","values","profiles","unshift","apply","this","arguments","originalParse","parse","result","movieId","video","timedTextracks","timedtexttracks","set","new_track_id","storeSubTrack","Function","Proxy","target","originalThis","args","property","apiAvailable"],"sourceRoot":""}