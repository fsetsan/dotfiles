{"version":3,"file":"/pages/emby-jellyfin-page.js","mappings":"6DA+BO,MAAMA,EAAgBC,IAClB,CAAEC,GAAIC,EAAQF,MAASA,IAErBE,EAAWF,GACb,GAAGA,EAAIG,YAAYH,EAAII,SAASJ,EAAIK,K,GClC3CC,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAaE,QAGrB,IAAIC,EAASN,EAAyBE,GAAY,CAGjDG,QAAS,CAAC,GAOX,OAHAE,EAAoBL,GAAUI,EAAQA,EAAOD,QAASJ,GAG/CK,EAAOD,OACf,CCrBAJ,EAAoBO,EAAI,CAACH,EAASI,KACjC,IAAI,IAAIC,KAAOD,EACXR,EAAoBU,EAAEF,EAAYC,KAAST,EAAoBU,EAAEN,EAASK,IAC5EE,OAAOC,eAAeR,EAASK,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDT,EAAoBU,EAAI,CAACK,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,G,UCClFI,SAASC,iBAAiB,6BAA6BC,UACnD,MAAMC,EAAW,CAAEC,MAAO,GAAIC,SAAU,GAAIC,UAAW,IACvD,IAAKC,UAED,OADAJ,EAASC,MAAQ,yBACVJ,SAASQ,cAAc,IAAIC,YAAY,wBAAyB,CACnEC,OAAQP,KAGhB,MAAMQ,EAAWJ,WAAWK,UAC5B,IAAIC,EACJ,IAAK,IAAIC,EAAU,EAAGA,EAAU,IAE5BD,SADuBN,UAAUQ,YAAY,CAAEC,SAAUL,KACtC,IACfE,EAAQI,UAAUC,eAHSJ,UAMzB,IAAIK,SAASC,GAAYC,WAAWD,EAAS,OAEvD,IAAKP,IAAYA,EAAQI,UAAUC,cAE/B,OADAf,EAASC,MAAQ,4DACVJ,SAASQ,cAAc,IAAIC,YAAY,wBAAyB,CACnEC,OAAQP,KAGhB,IAAImB,EAAUT,EAAQI,UAAUC,cAC5BK,EAAiBV,EAAQW,eAC7BrB,EAASE,SAAWkB,EAAeE,UAAYF,EAAeG,KAC9D,MAAMpB,EAAY,GAClBiB,EAAeI,aAAaC,QAAQC,GAAWA,EAAOC,uBAAsBC,SAASC,IACjF,MAAMC,EAAYD,EAAIE,KAAOF,EAAIE,KAAKC,MAAM,KAAKC,MAAQJ,EAAIK,MAC7D,IAAI3D,EAAM,WAAa6C,EAAee,GAAK,IAAMhB,EAAU,cAAgBU,EAAIO,MAAQ,WAAaN,EACpG3B,EAAUkC,MAAK,QAAa,CACxB/D,MAAOuD,EAAIS,aACXjE,SAAUwD,EAAIU,UAAY,GAC1BhE,IAAKA,EACLuD,cACD,IAEP9B,EAASG,UAAYA,EACrBN,SAASQ,cAAc,IAAIC,YAAY,wBAAyB,CAC5DC,OAAQP,IACT,IACJ,E","sources":["webpack://@project/extension/./src/pages/util.ts","webpack://@project/extension/webpack/bootstrap","webpack://@project/extension/webpack/runtime/define property getters","webpack://@project/extension/webpack/runtime/hasOwnProperty shorthand","webpack://@project/extension/./src/pages/emby-jellyfin-page.ts"],"sourcesContent":["export function extractExtension(url, fallback) {\n    const dotIndex = url.lastIndexOf('.');\n    let extension = fallback;\n    if (dotIndex !== -1) {\n        extension = url.substring(dotIndex + 1);\n        // Account for case when URL has a query parameter\n        const questionMarkIndex = extension.indexOf('?');\n        if (questionMarkIndex !== -1) {\n            extension = extension.substring(0, questionMarkIndex);\n        }\n    }\n    return extension;\n}\nexport function poll(test, timeout = 10000) {\n    return new Promise(async (resolve, reject) => {\n        if (test()) {\n            resolve(true);\n        }\n        const t0 = Date.now();\n        let passed = false;\n        while (!passed && Date.now() < t0 + timeout) {\n            await new Promise((loopResolve) => {\n                setTimeout(() => {\n                    passed = test();\n                    loopResolve();\n                }, 1000);\n            });\n        }\n        resolve(passed);\n    });\n}\nexport const trackFromDef = (def) => {\n    return { id: trackId(def), ...def };\n};\nexport const trackId = (def) => {\n    return `${def.language}:${def.label}:${def.url}`;\n};\nexport function inferTracks({ onJson, onRequest, waitForBasename }) {\n    setTimeout(() => {\n        const subtitlesByPath = {};\n        let basename = '';\n        let trackDataRequestHandled = false;\n        if (onJson !== undefined) {\n            const originalParse = JSON.parse;\n            JSON.parse = function () {\n                // @ts-ignore\n                const value = originalParse.apply(this, arguments);\n                let tracksFound = false;\n                let basenameFound = false;\n                onJson?.(value, (track) => {\n                    const path = window.location.pathname;\n                    if (typeof subtitlesByPath[path] === 'undefined') {\n                        subtitlesByPath[path] = [];\n                    }\n                    const newId = trackId(track);\n                    if (subtitlesByPath[path].find((s) => s.id === newId) === undefined) {\n                        subtitlesByPath[path].push({ id: newId, ...track });\n                        tracksFound = true;\n                    }\n                }, (theBasename) => {\n                    basename = theBasename;\n                    basenameFound = true;\n                });\n                if (trackDataRequestHandled && (tracksFound || basenameFound)) {\n                    // Only notify additional tracks after the initial request for track info\n                    document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n                        detail: {\n                            error: '',\n                            basename: basename,\n                            subtitles: subtitlesByPath[window.location.pathname],\n                        },\n                    }));\n                }\n                return value;\n            };\n        }\n        function garbageCollect() {\n            for (const path of Object.keys(subtitlesByPath)) {\n                if (path !== window.location.pathname) {\n                    delete subtitlesByPath[path];\n                }\n            }\n        }\n        document.addEventListener('asbplayer-get-synced-data', async () => {\n            onRequest?.((track) => {\n                const path = window.location.pathname;\n                if (typeof subtitlesByPath[path] === 'undefined') {\n                    subtitlesByPath[path] = [];\n                }\n                const newId = trackId(track);\n                if (subtitlesByPath[path].find((s) => s.id === newId) === undefined) {\n                    subtitlesByPath[path].push({ id: newId, ...track });\n                }\n            }, (theBasename) => {\n                basename = theBasename;\n                if (!trackDataRequestHandled) {\n                    // Notify basename even if still waiting for subtitle track info\n                    document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n                        detail: {\n                            error: '',\n                            basename: basename,\n                            subtitles: undefined,\n                        },\n                    }));\n                }\n            });\n            const ready = () => (!waitForBasename || basename !== '') && window.location.pathname in subtitlesByPath;\n            if (!ready()) {\n                await poll(ready);\n            }\n            document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n                detail: {\n                    error: '',\n                    basename: basename,\n                    subtitles: subtitlesByPath[window.location.pathname] ?? [],\n                },\n            }));\n            garbageCollect();\n            trackDataRequestHandled = true;\n        }, false);\n    }, 0);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { trackFromDef } from './util';\ndocument.addEventListener('asbplayer-get-synced-data', async () => {\n    const response = { error: '', basename: '', subtitles: [] };\n    if (!ApiClient) {\n        response.error = 'ApiClient is undefined';\n        return document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n            detail: response,\n        }));\n    }\n    const deviceID = ApiClient?._deviceId;\n    let session;\n    for (let attempt = 0; attempt < 5; attempt++) {\n        const sessions = await ApiClient.getSessions({ deviceId: deviceID });\n        session = sessions[0];\n        if (session.PlayState.MediaSourceId) {\n            break;\n        }\n        await new Promise((resolve) => setTimeout(resolve, 1000));\n    }\n    if (!session || !session.PlayState.MediaSourceId) {\n        response.error = 'Failed to retrieve a valid MediaSourceId after 5 attempts';\n        return document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n            detail: response,\n        }));\n    }\n    var mediaID = session.PlayState.MediaSourceId;\n    var nowPlayingItem = session.NowPlayingItem;\n    response.basename = nowPlayingItem.FileName ?? nowPlayingItem.Name;\n    const subtitles = [];\n    nowPlayingItem.MediaStreams.filter((stream) => stream.IsTextSubtitleStream).forEach((sub) => {\n        const extension = sub.Path ? sub.Path.split('.').pop() : sub.Codec;\n        var url = '/Videos/' + nowPlayingItem.Id + '/' + mediaID + '/Subtitles/' + sub.Index + '/Stream.' + extension;\n        subtitles.push(trackFromDef({\n            label: sub.DisplayTitle,\n            language: sub.Language || '',\n            url: url,\n            extension,\n        }));\n    });\n    response.subtitles = subtitles;\n    document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n        detail: response,\n    }));\n}, false);\n"],"names":["trackFromDef","def","id","trackId","language","label","url","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","document","addEventListener","async","response","error","basename","subtitles","ApiClient","dispatchEvent","CustomEvent","detail","deviceID","_deviceId","session","attempt","getSessions","deviceId","PlayState","MediaSourceId","Promise","resolve","setTimeout","mediaID","nowPlayingItem","NowPlayingItem","FileName","Name","MediaStreams","filter","stream","IsTextSubtitleStream","forEach","sub","extension","Path","split","pop","Codec","Id","Index","push","DisplayTitle","Language"],"sourceRoot":""}