{"version":3,"file":"/pages/youtube-page.js","mappings":"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","sources":["webpack://@project/extension/./src/pages/util.ts","webpack://@project/extension/webpack/bootstrap","webpack://@project/extension/webpack/runtime/define property getters","webpack://@project/extension/webpack/runtime/hasOwnProperty shorthand","webpack://@project/extension/./src/pages/youtube-page.ts"],"sourcesContent":["export function extractExtension(url, fallback) {\n    const dotIndex = url.lastIndexOf('.');\n    let extension = fallback;\n    if (dotIndex !== -1) {\n        extension = url.substring(dotIndex + 1);\n        // Account for case when URL has a query parameter\n        const questionMarkIndex = extension.indexOf('?');\n        if (questionMarkIndex !== -1) {\n            extension = extension.substring(0, questionMarkIndex);\n        }\n    }\n    return extension;\n}\nexport function poll(test, timeout = 10000) {\n    return new Promise(async (resolve, reject) => {\n        if (test()) {\n            resolve(true);\n        }\n        const t0 = Date.now();\n        let passed = false;\n        while (!passed && Date.now() < t0 + timeout) {\n            await new Promise((loopResolve) => {\n                setTimeout(() => {\n                    passed = test();\n                    loopResolve();\n                }, 1000);\n            });\n        }\n        resolve(passed);\n    });\n}\nexport const trackFromDef = (def) => {\n    return { id: trackId(def), ...def };\n};\nexport const trackId = (def) => {\n    return `${def.language}:${def.label}:${def.url}`;\n};\nexport function inferTracks({ onJson, onRequest, waitForBasename }) {\n    setTimeout(() => {\n        const subtitlesByPath = {};\n        let basename = '';\n        let trackDataRequestHandled = false;\n        if (onJson !== undefined) {\n            const originalParse = JSON.parse;\n            JSON.parse = function () {\n                // @ts-ignore\n                const value = originalParse.apply(this, arguments);\n                let tracksFound = false;\n                let basenameFound = false;\n                onJson?.(value, (track) => {\n                    const path = window.location.pathname;\n                    if (typeof subtitlesByPath[path] === 'undefined') {\n                        subtitlesByPath[path] = [];\n                    }\n                    const newId = trackId(track);\n                    if (subtitlesByPath[path].find((s) => s.id === newId) === undefined) {\n                        subtitlesByPath[path].push({ id: newId, ...track });\n                        tracksFound = true;\n                    }\n                }, (theBasename) => {\n                    basename = theBasename;\n                    basenameFound = true;\n                });\n                if (trackDataRequestHandled && (tracksFound || basenameFound)) {\n                    // Only notify additional tracks after the initial request for track info\n                    document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n                        detail: {\n                            error: '',\n                            basename: basename,\n                            subtitles: subtitlesByPath[window.location.pathname],\n                        },\n                    }));\n                }\n                return value;\n            };\n        }\n        function garbageCollect() {\n            for (const path of Object.keys(subtitlesByPath)) {\n                if (path !== window.location.pathname) {\n                    delete subtitlesByPath[path];\n                }\n            }\n        }\n        document.addEventListener('asbplayer-get-synced-data', async () => {\n            onRequest?.((track) => {\n                const path = window.location.pathname;\n                if (typeof subtitlesByPath[path] === 'undefined') {\n                    subtitlesByPath[path] = [];\n                }\n                const newId = trackId(track);\n                if (subtitlesByPath[path].find((s) => s.id === newId) === undefined) {\n                    subtitlesByPath[path].push({ id: newId, ...track });\n                }\n            }, (theBasename) => {\n                basename = theBasename;\n                if (!trackDataRequestHandled) {\n                    // Notify basename even if still waiting for subtitle track info\n                    document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n                        detail: {\n                            error: '',\n                            basename: basename,\n                            subtitles: undefined,\n                        },\n                    }));\n                }\n            });\n            const ready = () => (!waitForBasename || basename !== '') && window.location.pathname in subtitlesByPath;\n            if (!ready()) {\n                await poll(ready);\n            }\n            document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n                detail: {\n                    error: '',\n                    basename: basename,\n                    subtitles: subtitlesByPath[window.location.pathname] ?? [],\n                },\n            }));\n            garbageCollect();\n            trackDataRequestHandled = true;\n        }, false);\n    }, 0);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { trackFromDef } from './util';\nlet trustedPolicy = undefined;\nif (window.trustedTypes !== undefined) {\n    // YouTube doesn't define a default policy\n    // we create a default policy to avoid errors that seem to be caused by chrome not supporting trustedScripts in Function sinks\n    // If YT enforce a strict default policy in the future, we may need to revisit this\n    // hopefully by then chrome will have fixed the issue: https://wpt.fyi/results/trusted-types/eval-function-constructor.html\n    // (in chrome 127 the final test was failing)\n    if (window.trustedTypes.defaultPolicy === null) {\n        window.trustedTypes.createPolicy('default', {\n            createHTML: (s) => s,\n            createScript: (s) => s,\n            createScriptURL: (s) => s,\n        });\n    }\n    trustedPolicy = window.trustedTypes.createPolicy('passThrough', {\n        createHTML: (s) => s,\n        createScript: (s) => s,\n    });\n}\nconst adaptYtTrack = (track) => {\n    return trackFromDef({\n        label: `${track.languageCode} - ${track.name?.simpleText ?? track.name?.runs?.[0]?.text}`,\n        language: track.languageCode.toLowerCase(),\n        url: track.baseUrl,\n        extension: 'ytxml',\n    });\n};\ndocument.addEventListener('asbplayer-get-synced-data', async () => {\n    const response = { error: '', basename: '', subtitles: [] };\n    const initialHref = window.location.href;\n    try {\n        const playerContext = await fetch(window.location.href)\n            .then((webResponse) => {\n            if (!webResponse.ok) {\n                throw new Error(`YT Context Retrieval failed with Status ${webResponse.status}/${webResponse.statusText}...`);\n            }\n            return webResponse.text();\n        })\n            .then((pageString) => {\n            if (trustedPolicy !== undefined) {\n                pageString = trustedPolicy.createHTML(pageString);\n            }\n            return new window.DOMParser().parseFromString(pageString, 'text/html');\n        })\n            .then((page) => {\n            const scriptElements = page.body.querySelectorAll('script');\n            for (let i = 0; i < scriptElements.length; ++i) {\n                const elm = scriptElements[i];\n                if (elm.textContent?.includes('ytInitialPlayerResponse')) {\n                    let scriptString = `${elm.textContent}; return ytInitialPlayerResponse;`;\n                    if (trustedPolicy !== undefined) {\n                        scriptString = trustedPolicy.createScript(scriptString);\n                    }\n                    const context = new Function(scriptString)();\n                    if (context) {\n                        return context;\n                    }\n                }\n            }\n            return undefined;\n        });\n        if (!playerContext) {\n            throw new Error('YT Player Context not found...');\n        }\n        response.basename = playerContext.videoDetails?.title || document.title;\n        response.subtitles = (playerContext?.captions?.playerCaptionsTracklistRenderer?.captionTracks || []).map(adaptYtTrack);\n    }\n    catch (error) {\n        if (error instanceof Error) {\n            response.error = error.message;\n        }\n        else {\n            response.error = String(error);\n        }\n    }\n    finally {\n        if (initialHref === window.location.href) {\n            document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n                detail: response,\n            }));\n        }\n    }\n}, false);\nconst dataByVideoId = {};\nlet lastVideoIdDispatched;\nsetInterval(() => {\n    for (const videoId of Object.keys(dataByVideoId)) {\n        if (lastVideoIdDispatched !== videoId && window.location.pathname.includes(videoId)) {\n            document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n                detail: dataByVideoId[videoId],\n            }));\n            lastVideoIdDispatched = videoId;\n        }\n    }\n}, 500);\nconst originalParse = JSON.parse;\n// Hijack JSON in order to detect subtitle changes delivered asynchronously\nJSON.parse = function () {\n    // @ts-ignore\n    const value = originalParse.apply(this, arguments);\n    const tracks = value?.captions?.playerCaptionsTracklistRenderer?.captionTracks;\n    if (typeof tracks === 'object' && Array.isArray(tracks) && typeof value?.videoDetails?.videoId === 'string') {\n        const videoId = value.videoDetails.videoId;\n        const subtitles = tracks.map(adaptYtTrack);\n        const basename = value.videoDetails?.title || document.title;\n        dataByVideoId[videoId] = {\n            subtitles,\n            basename,\n            error: '',\n        };\n        if (location.pathname.includes(videoId)) {\n            document.dispatchEvent(new CustomEvent('asbplayer-synced-data', {\n                detail: {\n                    subtitles,\n                    basename,\n                    error: '',\n                },\n            }));\n        }\n    }\n    return value;\n};\n"],"names":["trackFromDef","def","id","trackId","language","label","url","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","trustedPolicy","window","trustedTypes","defaultPolicy","createPolicy","createHTML","s","createScript","createScriptURL","adaptYtTrack","track","languageCode","name","simpleText","runs","text","toLowerCase","baseUrl","extension","document","addEventListener","async","response","error","basename","subtitles","initialHref","location","href","playerContext","fetch","then","webResponse","ok","Error","status","statusText","pageString","DOMParser","parseFromString","page","scriptElements","body","querySelectorAll","i","length","elm","textContent","includes","scriptString","context","Function","videoDetails","title","captions","playerCaptionsTracklistRenderer","captionTracks","map","message","String","dispatchEvent","CustomEvent","detail","dataByVideoId","lastVideoIdDispatched","setInterval","videoId","keys","pathname","originalParse","JSON","parse","value","apply","this","arguments","tracks","Array","isArray"],"sourceRoot":""}