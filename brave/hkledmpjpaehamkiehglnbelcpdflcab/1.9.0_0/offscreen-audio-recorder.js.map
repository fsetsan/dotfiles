{"version":3,"file":"offscreen-audio-recorder.js","mappings":"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","sources":["webpack://@project/extension/../node_modules/sanitize-filename/index.js","webpack://@project/extension/../node_modules/truncate-utf8-bytes/browser.js","webpack://@project/extension/../node_modules/truncate-utf8-bytes/lib/truncate.js","webpack://@project/extension/../node_modules/utf8-byte-length/browser.js","webpack://@project/extension/webpack/bootstrap","webpack://@project/extension/webpack/runtime/get javascript chunk filename","webpack://@project/extension/webpack/runtime/global","webpack://@project/extension/webpack/runtime/hasOwnProperty shorthand","webpack://@project/extension/webpack/runtime/publicPath","webpack://@project/extension/webpack/runtime/jsonp chunk loading","webpack://@project/extension/../common/src/model.ts","webpack://@project/extension/../common/util/util.ts","webpack://@project/extension/../common/src/message.ts","webpack://@project/extension/../common/base64/index.ts","webpack://@project/extension/./src/services/audio-recorder.ts","webpack://@project/extension/../common/browser-detection/index.ts","webpack://@project/extension/../common/audio-clip/mp3-encoder.ts","webpack://@project/extension/./src/offscreen-audio-recorder.ts"],"sourcesContent":["/*jshint node:true*/\n'use strict';\n\n/**\n * Replaces characters in strings that are illegal/unsafe for filenames.\n * Unsafe characters are either removed or replaced by a substitute set\n * in the optional `options` object.\n *\n * Illegal Characters on Various Operating Systems\n * / ? < > \\ : * | \"\n * https://kb.acronis.com/content/39790\n *\n * Unicode Control codes\n * C0 0x00-0x1f & C1 (0x80-0x9f)\n * http://en.wikipedia.org/wiki/C0_and_C1_control_codes\n *\n * Reserved filenames on Unix-based systems (\".\", \"..\")\n * Reserved filenames in Windows (\"CON\", \"PRN\", \"AUX\", \"NUL\", \"COM1\",\n * \"COM2\", \"COM3\", \"COM4\", \"COM5\", \"COM6\", \"COM7\", \"COM8\", \"COM9\",\n * \"LPT1\", \"LPT2\", \"LPT3\", \"LPT4\", \"LPT5\", \"LPT6\", \"LPT7\", \"LPT8\", and\n * \"LPT9\") case-insesitively and with or without filename extensions.\n *\n * Capped at 255 characters in length.\n * http://unix.stackexchange.com/questions/32795/what-is-the-maximum-allowed-filename-and-folder-size-with-ecryptfs\n *\n * @param  {String} input   Original filename\n * @param  {Object} options {replacement: String | Function }\n * @return {String}         Sanitized filename\n */\n\nvar truncate = require(\"truncate-utf8-bytes\");\n\nvar illegalRe = /[\\/\\?<>\\\\:\\*\\|\"]/g;\nvar controlRe = /[\\x00-\\x1f\\x80-\\x9f]/g;\nvar reservedRe = /^\\.+$/;\nvar windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\\..*)?$/i;\nvar windowsTrailingRe = /[\\. ]+$/;\n\nfunction sanitize(input, replacement) {\n  if (typeof input !== 'string') {\n    throw new Error('Input must be string');\n  }\n  var sanitized = input\n    .replace(illegalRe, replacement)\n    .replace(controlRe, replacement)\n    .replace(reservedRe, replacement)\n    .replace(windowsReservedRe, replacement)\n    .replace(windowsTrailingRe, replacement);\n  return truncate(sanitized, 255);\n}\n\nmodule.exports = function (input, options) {\n  var replacement = (options && options.replacement) || '';\n  var output = sanitize(input, replacement);\n  if (replacement === '') {\n    return output;\n  }\n  return sanitize(output, '');\n};\n","'use strict';\n\nvar truncate = require(\"./lib/truncate\");\nvar getLength = require(\"utf8-byte-length/browser\");\nmodule.exports = truncate.bind(null, getLength);\n","'use strict';\n\nfunction isHighSurrogate(codePoint) {\n  return codePoint >= 0xd800 && codePoint <= 0xdbff;\n}\n\nfunction isLowSurrogate(codePoint) {\n  return codePoint >= 0xdc00 && codePoint <= 0xdfff;\n}\n\n// Truncate string by size in bytes\nmodule.exports = function truncate(getLength, string, byteLength) {\n  if (typeof string !== \"string\") {\n    throw new Error(\"Input must be string\");\n  }\n\n  var charLength = string.length;\n  var curByteLength = 0;\n  var codePoint;\n  var segment;\n\n  for (var i = 0; i < charLength; i += 1) {\n    codePoint = string.charCodeAt(i);\n    segment = string[i];\n\n    if (isHighSurrogate(codePoint) && isLowSurrogate(string.charCodeAt(i + 1))) {\n      i += 1;\n      segment += string[i];\n    }\n\n    curByteLength += getLength(segment);\n\n    if (curByteLength === byteLength) {\n      return string.slice(0, i + 1);\n    }\n    else if (curByteLength > byteLength) {\n      return string.slice(0, i - segment.length + 1);\n    }\n  }\n\n  return string;\n};\n\n","'use strict';\n\nfunction isHighSurrogate(codePoint) {\n  return codePoint >= 0xd800 && codePoint <= 0xdbff;\n}\n\nfunction isLowSurrogate(codePoint) {\n  return codePoint >= 0xdc00 && codePoint <= 0xdfff;\n}\n\n// Truncate string by size in bytes\nmodule.exports = function getByteLength(string) {\n  if (typeof string !== \"string\") {\n    throw new Error(\"Input must be string\");\n  }\n\n  var charLength = string.length;\n  var byteLength = 0;\n  var codePoint = null;\n  var prevCodePoint = null;\n  for (var i = 0; i < charLength; i++) {\n    codePoint = string.charCodeAt(i);\n    // handle 4-byte non-BMP chars\n    // low surrogate\n    if (isLowSurrogate(codePoint)) {\n      // when parsing previous hi-surrogate, 3 is added to byteLength\n      if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {\n        byteLength += 1;\n      }\n      else {\n        byteLength += 3;\n      }\n    }\n    else if (codePoint <= 0x7f ) {\n      byteLength += 1;\n    }\n    else if (codePoint >= 0x80 && codePoint <= 0x7ff) {\n      byteLength += 2;\n    }\n    else if (codePoint >= 0x800 && codePoint <= 0xffff) {\n      byteLength += 3;\n    }\n    prevCodePoint = codePoint;\n  }\n\n  return byteLength;\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = document.baseURI || self.location.href;\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t14: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// no jsonp function","export var ImageErrorCode;\n(function (ImageErrorCode) {\n    ImageErrorCode[ImageErrorCode[\"captureFailed\"] = 1] = \"captureFailed\";\n    ImageErrorCode[ImageErrorCode[\"fileLinkLost\"] = 2] = \"fileLinkLost\";\n})(ImageErrorCode || (ImageErrorCode = {}));\nexport var AudioErrorCode;\n(function (AudioErrorCode) {\n    AudioErrorCode[AudioErrorCode[\"drmProtected\"] = 1] = \"drmProtected\";\n    AudioErrorCode[AudioErrorCode[\"fileLinkLost\"] = 2] = \"fileLinkLost\";\n})(AudioErrorCode || (AudioErrorCode = {}));\nexport var VideoDataUiOpenReason;\n(function (VideoDataUiOpenReason) {\n    VideoDataUiOpenReason[VideoDataUiOpenReason[\"miningCommand\"] = 1] = \"miningCommand\";\n    VideoDataUiOpenReason[VideoDataUiOpenReason[\"failedToAutoLoadPreferredTrack\"] = 2] = \"failedToAutoLoadPreferredTrack\";\n    VideoDataUiOpenReason[VideoDataUiOpenReason[\"userRequested\"] = 3] = \"userRequested\";\n})(VideoDataUiOpenReason || (VideoDataUiOpenReason = {}));\nexport var PostMineAction;\n(function (PostMineAction) {\n    PostMineAction[PostMineAction[\"none\"] = 0] = \"none\";\n    PostMineAction[PostMineAction[\"showAnkiDialog\"] = 1] = \"showAnkiDialog\";\n    PostMineAction[PostMineAction[\"updateLastCard\"] = 2] = \"updateLastCard\";\n    PostMineAction[PostMineAction[\"exportCard\"] = 3] = \"exportCard\";\n})(PostMineAction || (PostMineAction = {}));\nexport var PostMinePlayback;\n(function (PostMinePlayback) {\n    PostMinePlayback[PostMinePlayback[\"remember\"] = 0] = \"remember\";\n    PostMinePlayback[PostMinePlayback[\"play\"] = 1] = \"play\";\n    PostMinePlayback[PostMinePlayback[\"pause\"] = 2] = \"pause\";\n})(PostMinePlayback || (PostMinePlayback = {}));\nexport var AutoPausePreference;\n(function (AutoPausePreference) {\n    AutoPausePreference[AutoPausePreference[\"atStart\"] = 1] = \"atStart\";\n    AutoPausePreference[AutoPausePreference[\"atEnd\"] = 2] = \"atEnd\";\n})(AutoPausePreference || (AutoPausePreference = {}));\nexport var PlayMode;\n(function (PlayMode) {\n    PlayMode[PlayMode[\"normal\"] = 1] = \"normal\";\n    PlayMode[PlayMode[\"condensed\"] = 2] = \"condensed\";\n    PlayMode[PlayMode[\"autoPause\"] = 3] = \"autoPause\";\n    PlayMode[PlayMode[\"fastForward\"] = 4] = \"fastForward\";\n    PlayMode[PlayMode[\"repeat\"] = 5] = \"repeat\";\n})(PlayMode || (PlayMode = {}));\nexport var ControlType;\n(function (ControlType) {\n    ControlType[ControlType[\"timeDisplay\"] = 0] = \"timeDisplay\";\n    ControlType[ControlType[\"subtitleOffset\"] = 1] = \"subtitleOffset\";\n    ControlType[ControlType[\"playbackRate\"] = 2] = \"playbackRate\";\n})(ControlType || (ControlType = {}));\n","import sanitize from 'sanitize-filename';\nexport function humanReadableTime(timestamp, nearestTenth = false) {\n    const totalSeconds = Math.floor(timestamp / 1000);\n    let seconds;\n    if (nearestTenth) {\n        seconds = Math.round(((timestamp / 1000) % 60) * 10) / 10;\n    }\n    else {\n        seconds = totalSeconds % 60;\n    }\n    const minutes = Math.floor(totalSeconds / 60) % 60;\n    const hours = Math.floor(totalSeconds / 3600);\n    if (hours > 0) {\n        return hours + 'h' + String(minutes).padStart(2, '0') + 'm' + String(seconds).padStart(2, '0') + 's';\n    }\n    return minutes + 'm' + String(seconds).padStart(2, '0') + 's';\n}\nexport function surroundingSubtitles(subtitles, index, countRadius, timeRadius) {\n    let startIndex = index;\n    for (let i = index; i >= 0; --i) {\n        startIndex = i;\n        if (atBoundary(subtitles, startIndex, index, countRadius, timeRadius, Direction.backward)) {\n            break;\n        }\n    }\n    let endIndex = startIndex;\n    for (let i = index; i <= subtitles.length - 1; ++i) {\n        endIndex = i;\n        if (atBoundary(subtitles, endIndex, index, countRadius, timeRadius, Direction.forward)) {\n            break;\n        }\n    }\n    return subtitles.slice(startIndex, endIndex + 1);\n}\nfunction indexNearTimestamp(subtitles, timestamp, direction) {\n    if (direction === Direction.forward) {\n        for (let i = 0; i < subtitles.length; ++i) {\n            if (subtitles[i].start >= timestamp) {\n                return i;\n            }\n        }\n    }\n    else {\n        for (let i = subtitles.length - 1; i >= 0; --i) {\n            if (subtitles[i].start <= timestamp) {\n                return i;\n            }\n        }\n    }\n    return undefined;\n}\nexport function surroundingSubtitlesAroundInterval(subtitles, startTimestamp, endTimestamp, countRadius, timeRadius) {\n    if (subtitles.length === 0) {\n        return {};\n    }\n    let startBoundaryIndex = 0;\n    const indexAfterStartTimestamp = indexNearTimestamp(subtitles, startTimestamp, Direction.forward) ?? subtitles.length - 1;\n    for (let i = 0; i < subtitles.length; ++i) {\n        startBoundaryIndex = i;\n        if (withinBoundaryAroundInterval(subtitles, i, countRadius, timeRadius, startTimestamp, indexAfterStartTimestamp)) {\n            break;\n        }\n    }\n    let endBoundaryIndex = subtitles.length - 1;\n    const indexBeforeEndTimestamp = indexNearTimestamp(subtitles, endTimestamp, Direction.backward) ?? 0;\n    for (let i = subtitles.length - 1; i >= 0; --i) {\n        endBoundaryIndex = i;\n        if (withinBoundaryAroundInterval(subtitles, i, countRadius, timeRadius, endTimestamp, indexBeforeEndTimestamp)) {\n            break;\n        }\n    }\n    if (endBoundaryIndex <= startBoundaryIndex) {\n        return {};\n    }\n    return {\n        surroundingSubtitles: subtitles.slice(startBoundaryIndex, endBoundaryIndex + 1),\n        subtitle: subtitles[indexAfterStartTimestamp],\n    };\n}\nexport function mockSurroundingSubtitles(middleSubtitle, maxTimestamp, timeRadius) {\n    const subtitles = [middleSubtitle];\n    const offset = middleSubtitle.start - middleSubtitle.originalStart;\n    if (middleSubtitle.end < maxTimestamp) {\n        const afterTimestamp = Math.min(maxTimestamp, middleSubtitle.end + timeRadius);\n        subtitles.push({\n            text: '',\n            start: middleSubtitle.end,\n            end: afterTimestamp,\n            originalStart: middleSubtitle.end - offset,\n            originalEnd: afterTimestamp - offset,\n            track: middleSubtitle.track,\n        });\n    }\n    if (middleSubtitle.start > 0) {\n        const beforeTimestamp = Math.max(0, middleSubtitle.start - timeRadius);\n        subtitles.unshift({\n            text: '',\n            start: beforeTimestamp,\n            end: middleSubtitle.start,\n            originalStart: beforeTimestamp - offset,\n            originalEnd: middleSubtitle.start - offset,\n            track: middleSubtitle.track,\n        });\n    }\n    return subtitles;\n}\nvar Direction;\n(function (Direction) {\n    Direction[Direction[\"forward\"] = 0] = \"forward\";\n    Direction[Direction[\"backward\"] = 1] = \"backward\";\n})(Direction || (Direction = {}));\nfunction atBoundary(subtitles, index, initialIndex, countRadius, timeRadius, direction) {\n    let next;\n    if (direction == Direction.forward) {\n        next = index + 1 < subtitles.length ? subtitles[index + 1] : null;\n    }\n    else {\n        next = index - 1 >= 0 ? subtitles[index - 1] : null;\n    }\n    if (Math.abs(initialIndex - index) >= countRadius &&\n        (next === null || Math.abs(next.start - subtitles[initialIndex].start) >= timeRadius)) {\n        return true;\n    }\n    return false;\n}\nfunction withinBoundaryAroundInterval(subtitles, index, countRadius, timeRadius, timestamp, indexNearTimestamp) {\n    const current = subtitles[index];\n    if (Math.abs(indexNearTimestamp - index) <= countRadius || Math.abs(current.start - timestamp) <= timeRadius) {\n        return true;\n    }\n    return false;\n}\nexport function subtitleIntersectsTimeInterval(subtitle, interval) {\n    const length = Math.max(0, subtitle.end - subtitle.start);\n    if (length === 0) {\n        return false;\n    }\n    const overlapStart = Math.max(subtitle.start, interval[0]);\n    const overlapEnd = Math.min(subtitle.end, interval[1]);\n    return overlapEnd - overlapStart >= length / 2;\n}\nexport function joinSubtitles(subtitles) {\n    return subtitles\n        .filter((s) => s.text.trim() !== '')\n        .map((s) => s.text)\n        .join('\\n');\n}\nexport function extractText(subtitle, surroundingSubtitles, track) {\n    if (surroundingSubtitles.length === 0) {\n        return subtitle.text;\n    }\n    const interval = [subtitle.start, subtitle.end];\n    return joinSubtitles(surroundingSubtitles\n        .filter((s) => subtitleIntersectsTimeInterval(s, interval))\n        .filter((s) => track === undefined || s.track === track));\n}\nexport function download(blob, name) {\n    const url = window.URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    document.body.appendChild(a);\n    a.style.display = 'none';\n    a.href = url;\n    a.download = sanitize(name);\n    a.click();\n    URL.revokeObjectURL(url);\n    a.remove();\n}\nexport function computeStyles({ subtitleColor, subtitleSize, subtitleThickness, subtitleOutlineThickness, subtitleOutlineColor, subtitleShadowThickness, subtitleShadowColor, subtitleBackgroundOpacity, subtitleBackgroundColor, subtitleFontFamily, subtitleCustomStyles, }) {\n    const styles = {\n        color: subtitleColor,\n        fontSize: `${subtitleSize}px`,\n        fontWeight: String(subtitleThickness),\n    };\n    if (subtitleOutlineThickness > 0) {\n        const thickness = subtitleOutlineThickness;\n        const color = subtitleOutlineColor;\n        styles['WebkitTextStroke'] = `${color} ${thickness}px`;\n    }\n    if (subtitleShadowThickness > 0) {\n        styles['textShadow'] = `0 0 ${subtitleShadowThickness}px ${subtitleShadowColor}, 0 0 ${subtitleShadowThickness}px ${subtitleShadowColor}, 0 0 ${subtitleShadowThickness}px ${subtitleShadowColor}, 0 0 ${subtitleShadowThickness}px ${subtitleShadowColor}`;\n    }\n    if (subtitleBackgroundOpacity > 0) {\n        const opacity = subtitleBackgroundOpacity;\n        const color = subtitleBackgroundColor;\n        const { r, g, b } = hexToRgb(color);\n        styles['backgroundColor'] = `rgba(${r}, ${g}, ${b}, ${opacity})`;\n    }\n    if (subtitleFontFamily && subtitleFontFamily.length > 0) {\n        styles['fontFamily'] = `'${subtitleFontFamily}'`;\n    }\n    for (const customStyle of subtitleCustomStyles) {\n        let key;\n        if (customStyle.key.startsWith('webkit') ||\n            customStyle.key.startsWith('moz') ||\n            customStyle.key.startsWith('ms') ||\n            /^o[A-Z].*/.test(customStyle.key)) {\n            key = customStyle.key.charAt(0).toUpperCase() + customStyle.key.slice(1);\n        }\n        else {\n            key = customStyle.key;\n        }\n        if (!isNumeric(key)) {\n            // A bug has allowed style keys that look like '0', '1',... to make it into some users' settings\n            // Using such a style key with react crashes the app, so filter them out here\n            styles[key] = customStyle.value;\n        }\n    }\n    return styles;\n}\nexport function isNumeric(str) {\n    return !isNaN(Number(str));\n}\n// https://stackoverflow.com/questions/63116039/camelcase-to-kebab-case\nfunction kebabize(str) {\n    const kebabized = str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? '-' : '') + $.toLowerCase());\n    if (kebabized.startsWith('webkit-') ||\n        kebabized.startsWith('moz-') ||\n        kebabized.startsWith('ms-') ||\n        kebabized.startsWith('o-')) {\n        return `-${kebabized}`;\n    }\n    return kebabized;\n}\nexport function computeStyleString(styleSettings) {\n    const stylesMap = computeStyles(styleSettings);\n    const styleList = [];\n    for (const [key, value] of Object.entries(stylesMap)) {\n        styleList.push(`${kebabize(key)}: ${value} !important`);\n    }\n    return styleList.join(';');\n}\n// https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb\nexport function hexToRgb(hex) {\n    var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    if (!result) {\n        return { r: 255, g: 255, b: 255 };\n    }\n    return {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16),\n    };\n}\nexport function sourceString(subtitleFileName, timestamp) {\n    return timestamp === 0 ? subtitleFileName : `${subtitleFileName} (${humanReadableTime(timestamp)})`;\n}\nexport function seekWithNudge(media, timestampSeconds) {\n    media.currentTime = timestampSeconds;\n    if (media.currentTime < timestampSeconds) {\n        // Seeking is imprecise and may not land on the desired timestamp\n        // Favor seeking slightly ahead to avoid getting stuck when seeking between subtitles\n        media.currentTime = Math.min(media.duration, media.currentTime + 0.01);\n    }\n    return media.currentTime;\n}\n","export var StartRecordingErrorCode;\n(function (StartRecordingErrorCode) {\n    StartRecordingErrorCode[StartRecordingErrorCode[\"noActiveTabPermission\"] = 1] = \"noActiveTabPermission\";\n    StartRecordingErrorCode[StartRecordingErrorCode[\"drmProtected\"] = 2] = \"drmProtected\";\n    StartRecordingErrorCode[StartRecordingErrorCode[\"other\"] = 3] = \"other\";\n})(StartRecordingErrorCode || (StartRecordingErrorCode = {}));\nexport var StopRecordingErrorCode;\n(function (StopRecordingErrorCode) {\n    StopRecordingErrorCode[StopRecordingErrorCode[\"timedAudioRecordingInProgress\"] = 1] = \"timedAudioRecordingInProgress\";\n    StopRecordingErrorCode[StopRecordingErrorCode[\"other\"] = 2] = \"other\";\n})(StopRecordingErrorCode || (StopRecordingErrorCode = {}));\n","export function bufferToBase64(buffer) {\n    let binary = '';\n    const bytes = new Uint8Array(buffer);\n    const length = bytes.byteLength;\n    for (let i = 0; i < length; ++i) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return window.btoa(binary);\n}\nexport async function fileUrlToBase64(fileUrl) {\n    return bufferToBase64(await (await fetch(fileUrl)).arrayBuffer());\n}\nexport const blobToBase64 = (blob) => {\n    return new Promise(async (resolve, reject) => {\n        try {\n            var reader = new FileReader();\n            reader.readAsDataURL(blob);\n            reader.onloadend = () => {\n                const result = reader.result;\n                const base64 = result.substring(result.indexOf(',') + 1);\n                resolve(base64);\n            };\n        }\n        catch (e) {\n            reject(e);\n        }\n    });\n};\nexport const base64ToBlob = (base64, mimeType) => {\n    const decoded = atob(base64);\n    const buffer = new Uint8Array(decoded.length);\n    for (let i = 0; i < buffer.length; ++i) {\n        buffer[i] = decoded.charCodeAt(i);\n    }\n    return new Blob([buffer.buffer], { type: mimeType });\n};\n","import { bufferToBase64 } from '@project/common/base64';\nexport class TimedRecordingInProgressError extends Error {\n}\nexport default class AudioRecorder {\n    constructor() {\n        this.recording = false;\n        this.recorder = null;\n        this.stream = null;\n        this.blobPromise = null;\n    }\n    startWithTimeout(stream, time, onStartedCallback, doNotManageStream = false) {\n        return new Promise(async (resolve, reject) => {\n            try {\n                if (this.recording) {\n                    console.error('Already recording, cannot start with timeout.');\n                    reject('Already recording');\n                    return;\n                }\n                await this.start(stream, doNotManageStream);\n                onStartedCallback();\n                this.timeoutResolve = resolve;\n                this.timeoutId = setTimeout(async () => {\n                    this.timeoutId = undefined;\n                    resolve(await this.stop(doNotManageStream));\n                }, time);\n            }\n            catch (e) {\n                reject(e);\n            }\n        });\n    }\n    start(stream, doNotManageStream = false) {\n        return new Promise((resolve, reject) => {\n            if (this.recording) {\n                reject('Already recording, cannot start');\n                return;\n            }\n            try {\n                const recorder = new MediaRecorder(stream);\n                const chunks = [];\n                recorder.ondataavailable = (e) => {\n                    chunks.push(e.data);\n                };\n                this.blobPromise = new Promise((resolve, reject) => {\n                    recorder.onstop = (e) => {\n                        resolve(new Blob(chunks));\n                    };\n                });\n                recorder.start();\n                if (!doNotManageStream) {\n                    const output = new AudioContext();\n                    const source = output.createMediaStreamSource(stream);\n                    source.connect(output.destination);\n                }\n                this.recorder = recorder;\n                this.recording = true;\n                this.stream = stream;\n                resolve(undefined);\n            }\n            catch (e) {\n                reject(e);\n            }\n        });\n    }\n    async stopSafely(doNotManageStream = false) {\n        this.recording = false;\n        this.recorder?.stop();\n        this.recorder = null;\n        if (!doNotManageStream) {\n            this.stream?.getTracks()?.forEach((t) => t.stop());\n            this.stream = null;\n        }\n        if (this.blobPromise !== null) {\n            const blob = await this.blobPromise;\n            this.blobPromise = null;\n            const base64 = await bufferToBase64(await blob.arrayBuffer());\n            if (this.timeoutId !== undefined) {\n                clearTimeout(this.timeoutId);\n                this.timeoutId = undefined;\n                this.timeoutResolve?.(base64);\n                this.timeoutResolve = undefined;\n            }\n        }\n    }\n    async stop(doNotManageStream = false) {\n        if (!this.recording) {\n            throw new Error('Not recording, unable to stop');\n        }\n        this.recording = false;\n        this.recorder?.stop();\n        this.recorder = null;\n        if (!doNotManageStream) {\n            this.stream?.getTracks()?.forEach((t) => t.stop());\n            this.stream = null;\n        }\n        const blob = await this.blobPromise;\n        this.blobPromise = null;\n        const base64 = await bufferToBase64(await blob.arrayBuffer());\n        if (this.timeoutId !== undefined) {\n            clearTimeout(this.timeoutId);\n            this.timeoutId = undefined;\n            this.timeoutResolve?.(base64);\n            this.timeoutResolve = undefined;\n            throw new TimedRecordingInProgressError();\n        }\n        return base64;\n    }\n}\n","export const isFirefox = navigator.userAgent.toLowerCase().includes('firefox');\n","export default class Mp3Encoder {\n    static async encode(blob, workerFactory) {\n        return new Promise(async (resolve, reject) => {\n            var reader = new FileReader();\n            reader.onload = async (e) => {\n                try {\n                    const audioContext = new AudioContext();\n                    if (e.target === null) {\n                        reject(new Error('Could not obtain buffer to encode'));\n                        return;\n                    }\n                    const audioBuffer = await audioContext.decodeAudioData(e.target.result);\n                    const channels = [];\n                    for (let i = 0; i < audioBuffer.numberOfChannels; ++i) {\n                        channels.push(audioBuffer.getChannelData(i));\n                    }\n                    const workerValue = workerFactory();\n                    const worker = workerValue instanceof Worker ? workerValue : await workerValue;\n                    worker.postMessage({\n                        command: 'encode',\n                        audioBuffer: {\n                            channels: channels,\n                            numberOfChannels: audioBuffer.numberOfChannels,\n                            length: audioBuffer.length,\n                            sampleRate: audioBuffer.sampleRate,\n                        },\n                    });\n                    worker.onmessage = (e) => {\n                        resolve(new Blob(e.data.buffer, { type: 'audio/mp3' }));\n                        worker.terminate();\n                    };\n                    worker.onerror = (e) => {\n                        const error = e?.error ?? new Error('MP3 encoding failed: ' + e?.message);\n                        reject(error);\n                        worker.terminate();\n                    };\n                }\n                catch (e) {\n                    reject(e);\n                }\n            };\n            reader.readAsArrayBuffer(blob);\n        });\n    }\n}\n","import { StartRecordingErrorCode, StopRecordingErrorCode, } from '@project/common';\nimport AudioRecorder, { TimedRecordingInProgressError } from './services/audio-recorder';\nimport { Mp3Encoder } from '@project/common/audio-clip';\nimport { bufferToBase64 } from '@project/common/base64';\nconst audioRecorder = new AudioRecorder();\nconst _sendAudioBase64 = async (base64, requestId, encodeAsMp3) => {\n    if (encodeAsMp3) {\n        const blob = await (await fetch('data:audio/webm;base64,' + base64)).blob();\n        const mp3Blob = await Mp3Encoder.encode(blob, () => new Worker(new URL('../../common/audio-clip/mp3-encoder-worker.ts', import.meta.url)));\n        base64 = bufferToBase64(await mp3Blob.arrayBuffer());\n    }\n    const command = {\n        sender: 'asbplayer-offscreen-document',\n        message: {\n            command: 'audio-base64',\n            base64,\n            requestId,\n        },\n    };\n    chrome.runtime.sendMessage(command);\n};\nconst _stream = async (streamId) => {\n    return navigator.mediaDevices.getUserMedia({\n        audio: {\n            // @ts-ignore\n            mandatory: {\n                chromeMediaSource: 'tab',\n                chromeMediaSourceId: streamId,\n            },\n        },\n    });\n};\nlet currentRequestId;\nconst errorResponseForError = (e) => {\n    let errorCode;\n    if (e instanceof DOMException && e.name === 'AbortError') {\n        errorCode = StartRecordingErrorCode.noActiveTabPermission;\n    }\n    else {\n        errorCode = StartRecordingErrorCode.other;\n    }\n    return {\n        started: false,\n        error: { code: errorCode, message: e.message },\n    };\n};\nwindow.onload = async () => {\n    const listener = (request, sender, sendResponse) => {\n        if (request.sender === 'asbplayer-extension-to-offscreen-document') {\n            switch (request.message.command) {\n                case 'start-recording-audio-with-timeout':\n                    const startRecordingAudioWithTimeoutMessage = request.message;\n                    _stream(startRecordingAudioWithTimeoutMessage.streamId)\n                        .then((stream) => {\n                        return audioRecorder.stopSafely().then(() => audioRecorder.startWithTimeout(stream, startRecordingAudioWithTimeoutMessage.timeout, () => {\n                            const successResponse = { started: true };\n                            sendResponse(successResponse);\n                        }));\n                    })\n                        .then((audioBase64) => _sendAudioBase64(audioBase64, startRecordingAudioWithTimeoutMessage.requestId, startRecordingAudioWithTimeoutMessage.encodeAsMp3))\n                        .catch((e) => {\n                        console.error(e);\n                        sendResponse(errorResponseForError(e));\n                    });\n                    return true;\n                case 'start-recording-audio':\n                    const startRecordingAudioMessage = request.message;\n                    currentRequestId = startRecordingAudioMessage.requestId;\n                    _stream(startRecordingAudioMessage.streamId)\n                        .then((stream) => audioRecorder.stopSafely().then(() => audioRecorder.start(stream)))\n                        .then(() => sendResponse({ started: true }))\n                        .catch((e) => {\n                        console.error(e);\n                        sendResponse(errorResponseForError(e));\n                    });\n                    return true;\n                case 'stop-recording-audio':\n                    const stopRecordingAudioMessage = request.message;\n                    audioRecorder\n                        .stop()\n                        .then((audioBase64) => {\n                        const successResponse = {\n                            stopped: true,\n                        };\n                        sendResponse(successResponse);\n                        _sendAudioBase64(audioBase64, currentRequestId, stopRecordingAudioMessage.encodeAsMp3);\n                    })\n                        .catch((e) => {\n                        let errorCode;\n                        if (e instanceof TimedRecordingInProgressError) {\n                            errorCode = StopRecordingErrorCode.timedAudioRecordingInProgress;\n                        }\n                        else {\n                            console.error(e);\n                            errorCode = StopRecordingErrorCode.other;\n                        }\n                        const errorResponse = {\n                            stopped: false,\n                            error: {\n                                code: errorCode,\n                                message: e.message,\n                            },\n                        };\n                        sendResponse(errorResponse);\n                    });\n                    return true;\n            }\n        }\n    };\n    chrome.runtime.onMessage.addListener(listener);\n    window.addEventListener('beforeunload', (event) => {\n        chrome.runtime.onMessage.removeListener(listener);\n    });\n};\n"],"names":["truncate","illegalRe","controlRe","reservedRe","windowsReservedRe","windowsTrailingRe","sanitize","input","replacement","Error","sanitized","replace","module","exports","options","output","getLength","bind","isHighSurrogate","codePoint","isLowSurrogate","string","byteLength","segment","charLength","length","curByteLength","i","charCodeAt","slice","prevCodePoint","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","m","u","chunkId","g","globalThis","this","Function","e","window","o","obj","prop","Object","prototype","hasOwnProperty","call","scriptUrl","importScripts","location","document","currentScript","src","scripts","getElementsByTagName","p","b","baseURI","self","href","VideoDataUiOpenReason","PostMineAction","PostMinePlayback","AutoPausePreference","PlayMode","ControlType","AudioErrorCode","ImageErrorCode","Direction","StartRecordingErrorCode","StopRecordingErrorCode","bufferToBase64","buffer","binary","bytes","Uint8Array","String","fromCharCode","btoa","TimedRecordingInProgressError","navigator","userAgent","toLowerCase","includes","encode","blob","workerFactory","Promise","async","resolve","reject","reader","FileReader","onload","audioContext","AudioContext","target","audioBuffer","decodeAudioData","result","channels","numberOfChannels","push","getChannelData","workerValue","worker","Worker","postMessage","command","sampleRate","onmessage","Blob","data","type","terminate","onerror","error","message","readAsArrayBuffer","audioRecorder","constructor","recording","recorder","stream","blobPromise","startWithTimeout","time","onStartedCallback","doNotManageStream","console","start","timeoutResolve","timeoutId","setTimeout","stop","MediaRecorder","chunks","ondataavailable","onstop","createMediaStreamSource","connect","destination","stopSafely","getTracks","forEach","t","base64","arrayBuffer","clearTimeout","_sendAudioBase64","requestId","encodeAsMp3","fetch","mp3Blob","URL","sender","chrome","runtime","sendMessage","_stream","streamId","mediaDevices","getUserMedia","audio","mandatory","chromeMediaSource","chromeMediaSourceId","currentRequestId","errorResponseForError","errorCode","DOMException","name","noActiveTabPermission","other","started","code","listener","request","sendResponse","startRecordingAudioWithTimeoutMessage","then","timeout","audioBase64","catch","startRecordingAudioMessage","stopRecordingAudioMessage","stopped","timedAudioRecordingInProgress","errorResponse","onMessage","addListener","addEventListener","event","removeListener"],"sourceRoot":""}